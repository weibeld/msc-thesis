At the beginning of the 1960s, a Swiss logician named Julius Richard Büchi at Michigan University was looking for a way to prove the decidability of the satisfiability of monadic second order logic with one successor (S1S). Büchi applied a trick that truly founded a new paradigm in the application of logic to theoretical computer science. He thought of interpretations of a S1S formula as infinitly long words of a formal language and designed a type of finite state automaton that accepts such a word if and only if the interpretation it represents satisfies the formula. After proving that every S1S formula can be translated to such an automaton and vice versa (Büchi's Theorem), the satisfiabilty problem of an S1S formula could be reduced to testing the non-emptiness of the corresponding automaton.

This special type of finite state automaton was later called Büchi automaton.

\section{Context of Study}
\label{1_context}
%% Büchi automata and Büchi complementation

\subsection{Büchi Automata and Büchi Complementation}

Büchi automata are finite state automata that process words of infinite length, so called \om-words. If $\Sigma$ is the alphabet of a Büchi automaton, then the set of all the possible \om-words that can be generated from this alphabet is denoted by $\Sigma^\omega$. A word $\alpha \in \Sigma^\omega$ is accepted by a Büchi automaton if it results in at least one run that contains at least one accepting state infinitely often. A run of a Büchi automaton on a word is a sequence of states. Deterministic Büchi automata have exactly one run for each word in $\Sigma^\omega$, whereas non-deterministic Büchi automata may have multiple runs for each word.

The complement of a Büchi automaton $A$ is another Büchi automaton\footnote{The fact that Büchi automata are closed under complementation has been proved by Büchi~\cite{buchi1960decision}, who, to this end, described the first Büchi complementation construction in history.} and is denoted by $\cl1{A}$. Both, $A$ and $\cl1{A}$, share the same alphabet $\Sigma$. Regarding any word $\alpha \in \Sigma^\omega$, the relation between an automaton and its complement is as follows:

\begin{quote}
\centering
$\alpha$ accepted by $A$ $\Longleftrightarrow$ $\alpha$ not accepted by $\cl1{A}$
\end{quote}

That is, all the words that are \textit{accepted} by an automaton are \textit{rejected} by its complement, and all the words that are \textit{rejected} by an automaton are \textit{accepted} by its complement. In other words, there is no single word that is either accepted or rejected by \textit{both} of an automaton and its complement.

The complementation of Büchi automata, in particular non-deterministic Büchi automata, is commonly known as ``Büchi complementation'' or the ``Büchi complementation problem''. It is a very complex problem because it exhibits a very high state growth, which is sometimes even called state explosion (in the following, we will use the terms state growth, state explosion, and state complexity interchangeably). State growth denotes the relation of the number of states of a complement $\cl1{A}$ (output of the complementation construction) to the number of states of the automaton $A$ (input to the complementation construction). This relation is for worst-case automata exponential, even for an ideal complementation construction\footnote{Yan proved in 2007 a lower bound for the worst-case state growth of Büchi complementation of $(0.76n)^n$, where $n$ is the number of states of the initial automaton~\cite{DBLP:journals/corr/abs-0802-1226}.}. Even though the state growth that existing complementation constructions produce for many non-worst-case automata is not nearly as high as the worst case, it may still be very high. This is a serious problem, because Büchi complementation has important practical applications (as we will see next), and it is the reason that the quest for more efficient and more practical Büchi complementation constructions is still an active research topic today.


\subsection{Language Containment}
An important application of Büchi complementation is language containment of \om-regular languages. The \om-regular languages form the class of languages that is equivalent to non-deterministic Büchi automata. The language containment problem consists in determining whether $L_1 \subseteq L_2$, that is, whether a language $L_1$ is \textit{contained} in another langauge $L_2$. This is true if every word of $L_1$ is also in $L_2$.

The way $L_1 \subseteq L_2$ is commonly resolved is by testing $L_1 \cap \cl1{L_2} = \varnothing$. Here, $\cl1{L_2}$ denotes the complement language of $L_2$. This means, we have to create the intersection language, say $L_{1,\cl1{2}}$ of $L_1$ and the complement of $L_2$, and then test whether $L_{1,\cl1{2}}$ is empty (that is, contains no words at all). If $L_{1,\cl1{2}}$ is empty, then there is no word of $L_1$ that is not also in $L_2$, and $L_1 \subseteq L_2$ is true. If $L_{1,\cl1{2}}$ is non-empty, then there is at least one word of $L_1$ that is not in $L_2$, and $L_1 \subseteq L_2$ is false.

With this procedure, we in fact reduce the language containment problem to three operations on languages: complementation, intersection, and emptiness testing. By translating the languages $L_1$ and $L_2$ to equivalent automata $A_1$ and $A_2$, and mainpulating the automata instead of the languages, the problem becomes $L(A_1 \cap \cl1{A_2}) = \varnothing$. That is, we complement $A_2$, create the intersection automaton $A_{1,\cl1{2}}$ of $A_1$ and the complement of $A_2$, and test whether the language of $A_{1,\cl1{2}}$ is empty, which is done by directly testing the automaton $A_{1,\cl1{2}}$ for emptiness.

In this way, we reduce the language containment problem of \om-regular languages to three operations on non-deterministic Büchi automata: complementation, intersection, and emptiness testing. Büchi complementation is thus an integral part of the language contaiment problem. However, this does not yet answer our initial question of what is a \textit{concrete} and \textit{practical} application of Büchi complementation. To answer this question, we will in the following describe one important application of langauge containment of \om-regular languages.


% One of the main applications of Büchi complementation is language containment of \om-regular languages. This means to find out whether all the words of a language $L_1$ are also contained in another language $L_2$, formally written as $L_1 \subseteq L_2$.

% The way this problem is solved is by testing $L_1 \cap \cl1{L_2} = \varnothing$. That is, one takes the intersection of the first (contained) language and the \textit{complement} of the second (containing) language, and tests whether this intersection is empty. If yes, then all the words of $L_1$ are also contained in $L_2$, and $L_1 \subseteq L_2$ is true. If no, then there is at least one word of $L_1$ that is not contained in $L_2$, and $L_1 \subseteq L_2$ is false.

% If we represent languages as automata, then the problem becomes $L(A_1) \subseteq L(A_2)$, which is solved by testing $L(A_1) \cap L(\cl1{A_2}) = \varnothing$. That means, we have to complement the automton $A_2$.


\subsection{Automata-Theoretic Model Checking via Language Containment}

\subsubsection{How It Works}
The language containment approach to automata-theoretic model checking is an approach to automata-theoretic model checking, which is an approach to general model checking, which in turn is an approch to formal verification~\cite{2007_vardi_model_checking}. Figure~\ref{model_checking} shows the branch of the family of formal verification techniques that contains the language containment approach to automata-theoretic model checking.

\begin{figure}[htb]
\centering
\ModelChecking
\caption{Branch of the family of formal verification techniques that contains the language containment approach to automata-theoretic model checking.}
\label{model_checking}
\end{figure}

Formal verification is the use of mathemtical techniques for proving the correctness of a system (software of hardware) with respect to a specified set of properties~\cite{2007_vardi_model_checking}. A typical example is to verify that a program is deadlock-free. In general, formal verification techniques consist of the following three parts~\cite{huth2004logic}:

\begin{enumerate}
\item A framework for modelling the system to verify
\item A framework for specifying the properties that the system must satisfy
\item A verification method for testing whether the system satisfies the properties
\end{enumerate}

For the language containment approach to automata-theoretic model checking, the frameworks for modelling the system to verify and for specifying the properties to be verified are both Büchi automata. The verification method is to test language containment of the languages corresponding to the two Büchi automata. In more detail, the approach works as we explain in the following.

The system $s$ to be verified is modelled as a Büchi automaton, say $S$. Each word of the language $L(S)$ of $S$ corresponds to a possible computation trace of the system $s$. A computation trace is an infinite sequence of ``combinations of properties'' of the system. Such properties can be for example variable values or statuses of individual processes. Each element of a computation trace corresponds to a point in time during the execution of the system\footnote{The infinity of computation traces suggests that this type of formal verification (and model checking in general) is used for systems that are not expected to terminate and  may run indefinitely. This type of systems is called \textit{reactive} systems. They contrast with systems that are expected to terminate and produce a result. For this latter type of systems other formal verification techniques than model checking are used. See for example~\cite{huth2004logic} and~\cite{ben2012mathematical} for works that cover the formal verification of both types of systems.}. The language $L(S)$ represents thus everything that the system \textit{can} do.

A property $p$ to be verified is represented as a non-deterministic Büchi automaton, say $P$. The words of the language $L(P)$ of $P$ also represent computation traces. In particular, the language $L(P)$ represents all the possible computation traces that do satisfy the property $p$. If for example $p$ is ``deadlock-freeness'', then $L(P)$ contains all the possible computation traces of a system like $s$ that are deadlock-free. In other words, the language $L(P)$ represents everything that a system is \textit{allowed} to do, with respect to a property $p$.

The verification step then consists in testing $L(S) \subseteq L(P)$, that is, whether everything that the system \textit{can} do is contained in everything that the system is \textit{allowed} to do. If this is true, then every possible computation trace of the system satisfies the property $p$, because it is contained in $L(P)$. If $p$ means deadlock-freeness, then we can conclude that the system is deadlock-free. If the language containment test returns a negative result, then there must be at least one computation trace of the system that does not satisfiy the property $p$, because it is not in $L(P)$. In that case, this computation trace (however improbable it is), for example, leads to a deadlock, and we have to conclude that the system is not deadlock-free.

This short description points out the application of language containment in formal verification, and, as we know, language containment of \om-regular languages requires Büchi complementation. In the following, we will briefly mention some interesing points about the specific role of Büchi complementation in automata-theoretic model checking.

\subsubsection{Importance of Büchi Complementation}

As we have seen in the previous section, solving the language containment problem $L(S) \subseteq L(P)$ is done by translating it to the automata-theoretic problem $L(S \cap \cl1{P}) = \varnothing$, which in turn is solved by the following three steps:

\begin{enumerate}
\item Construct the \textit{complement} $\cl1{P}$ of the property automaton $P$
\item Construct the \textit{intersection} automaton, say $A_{S,\cl1{P}}$, of $S$ and $\cl1{P}$
\item Test $A_{S,\cl1{P}}$ for \textit{emptiness}
\end{enumerate}

The formal verification problem is thus reduced to three operations on Büchi automata, \textit{complementation}, \textit{intersection}, and \textit{emptiness testing}. Complementation is clearly the problem child of this triple. For intersection and emptiness testing of Büchi automata there exist efficient solutions~\cite{2007_vardi_model_checking} (cf.~\cite{1996_vardi}). Büchi complementation, however, is so complex that it makes the entire approach impractical~\cite{1995_tasiran}. According to~\cite{2007_vardi_model_checking}, there are so far no verification tools that include the complementation of a non-deterministic property automaton, because of the sheer time and computing resources that it entails.

Instead, verification tools apply different ways to circumvent the need for complementing non-deterministic property automata. One of them is to use a deterministic, rather than a non-deterministic, Büchi automaton for representing the property~\cite{1995_tasiran}\cite{2007_vardi_model_checking}. This is because the complementation of determinstic Büchi automata is easy (it can be done in polynomial time and linear space~\cite{Kurshan198759}). This has however the disadvantage that the resulting deterministic automaton may be considerably bigger than an equivalent non-deterministic automaton, and that it is generally more complicated and less intuitive to specify a property as a deterministic automaton~\cite{1995_tasiran}.

Another way to cirvumvent the need for Büchi complementation is to use a slightly different approach to automata-theoretic model checking (in Figure~\ref{model_checking}, a sibling of the language containment approach)~\cite{2007_vardi_model_checking}. In this approach, the property is not specified as a Büchi automaton, but as a linear temporal logic (LTL) formula $\varphi$. The formula $\varphi$ is then negated ($\neg\varphi$) and translated to a Büchi automaton $A_{\neg\varphi}$. If $A_S$ is the system automaton, then the verification step is done by testing $L(A_S \cap A_{\neg\varphi}) = \varnothing$. This works because $A_{\neg\varphi}$ is equivalent to $\cl1{A_{\varphi}}$, that is, the complement of the automaton representing the property. In this way we push off complementation from Büchi automata to LTL formulas, in which case it is trivial. A verification tool that uses this approach is the SPIN model checker~\cite{1997_spin}. The disadvantage of this approach is that LTL is less expressive than Büchi automata, and thus allows to express fewer properties. It has even been stated that the set of properties that can be expressed with LTL is unsufficient for industrial applications~\cite{2007_vardi_model_checking}.

Summarising, we can say that automata-theoretic model checking is possible without Büchi complementation. However, the language containment approach with the direct specification of the property as a non-deterministic Büchi automaton has important practical advantages. Thus, finding more efficient ways for the complementation of non-deterministic Büchi automata would be of high practical value~\cite{2007_vardi_model_checking}. This motivates the fundamental topic of this thesis. In the next sections, we will see how our work specifically contributes to this quest.


\subsection{Stating the problem, reason the research is worth tackling}

\subsubsection{Worst-Case State Growth as Main Performance Measure} 
Since the introduction of Büchi automata in 1962, many different Büchi complementation constructions have been proposed (see our review in Section~\ref{2_constructions}). The main performance measure for these constructions has usually been their so-called \textit{worst-case state growth} or \textit{worst-case state complexity} (in the following, we will use these two terms interchangeably\footnote{Further terms used in the literature are state blow-up or state explosion.}).

State growth basically denotes the number of states of the output automaton in relation to the number of states of the input automaton to a complementation construction. Each automaton has thus its specific own state growth with each construction. The worst-case state growth of a construction results from a theoretical worst-case automaton, which has a higher state growth than any other automaton. In different words, the worst-case state growth is the maximum number of states that a concstruction \textit{can} generate.

The state growth and the resulting time and space complexity is the biggest issue of Büchi complementation. The worst-case state growth seems to ``distill'' this issue to a single number which is practical to use as a concise performance measure and to compare different constructions with each other. Thus, much of the research effort in Büchi complementation construction has gone into reducing the worst-case state growth.

For example, the complementation construction that has been described in 1962 by Büchi himself~\cite{buchi1960decision} has a doubly exponential worst-case state growth of $2^{2^{O\left(n\right)}}$, where $n$ is the number of states of the input automaton\footnote{In the following, we will always notate state growths as a function of $n$, and $n$ will always be the number of states of the input automaton.}. Note that worst-case state growths are often not given as exact functions, but include the big O notation. A later construction from 1987 by Sistla, Vardi, and Wolper~\cite{PrasadSistla1987217} reduces this worst-case state complexity to a singly exponential funtion of $O\left(2^{4n^2}\right)$. More recently, a construction from 2006 by Friedgut, Kupferman and Vardi from 2006~\cite{friedgut2006buchi} has a worst-caste state complexity of only $(0.96n)^n$.

In parallel to the quest for complementation constructions with a low worst-case state complexity, there is a quest for finding the worst-caste state complexity of Büchi complementation itself. This is done by showing a theoretical minimum state growth of certain automata which even an ideal complementation construction could not undermatch. In this way, one proves a \textit{lower bound} for the worst-case complexity of Büchi complementation (it is still possible that there exist automata with an even higher theoretical minimum state growth). In 1988 Michel proved  such a lower bound of $n!$~\cite{michel1988} (in a different notation approximately $(0.36n)^n$). In 2008, Yan proved a new lower bound of $(0.76n)^n$~\cite{DBLP:journals/corr/abs-0802-1226}. This result is still valid at the time of this writing.

A lower bound of $(0.76n)^n$ means that no complementation construction can ever have a worst-case state growth lower than $(0.76n)^n$. Consequently, a construction that achieves this worst-case state growth is commonly regarded as ``optimal''. 

\subsubsection{Importance of Empirical Performance Investigations}
Worst-case state growths are certainly interesting from a theoretical point of view. However, they can be seen as only one aspect of the performance of Büchi complementation constructions. The reality is certainly much more complex. If, for example, one is interested in practical questions (like how does a construction peform on a concrete automaton?), then worst-case state growths are a poor guide to the concrete performance of the construction~\cite{2011_tsai}.

For example, if we have a concrete automaton, then the worst-case state growth does not reveal anything about how big the complement of this concrete automaton will be. It is not even clear whether in a concrete case a construction with a lower worst-case state growth produces a smaller complement than a construction with a higher worst-case state growth.

Worst-case state growths are mainly meaningful for the worst cases. However, if these worst cases would occur, then all constructions would be far from practical anyway~\cite{1995_tasiran}. If we take for example Friedgut, Kupferman, and Vardi's construction~\cite{friedgut2006buchi} with a worst-case complexity of $(0.96n)^n$, Sistla, Vardi, and Wolper's construction with a worst-case complexity of $O\left(2^{4n^2}\right)$, and a ``worst-case'' automata of, say, 15 states, then the complements of the two constructions would have $2.73 \times 10^17$ (23.7 million billion) and $8.45 \times 10^270$ states, respectively. While this difference is still huge, in practice this does not matter much, because both cases are most likely anyway not feasible in practice.

Hence, with regard to the practical application of Büch complementation (see Section~\ref{1_context}), we believe that it is important to investigate the \textit{actual} performance of Büchi complementation constructions on \textit{concrete} input automata. This is done by \textit{empirical} performance investigations that includes an implementation of the investigated construction, and a set of test data.

There have bee not many empirical investigations of Büchi complementation constructions, and most of the time they have been used as a proof of concept that a given construction \textit{can} be applied in practice. Tasiran et al. (1995)~\cite{1995_tasiran} created an efficient implementation of Safra's complementation construction and used it with the HSIS formal verification tool~\cite{1994_hsis} for automata-theoretic model checking tasks. They could easily complement property automata with some hundreds of states. However, they do not statistically evaluate the results.

In 2003, Gurumurthy et al.~\cite{2003_Gurumurthy} implemented Friedgut, Kupferman, and Vardi's complementation construction~\cite{Kupferman:2001} with different optimisations as part of the tool Wring~\cite{somenzi2000efficient}. They complemented 1000 small automata, that were generated by translation from LTL formulas, and made basic statistical evaluation comparing the effect of the different optimisations on the performance.

In 2006, Althoff et al.~\cite{2006_althoff} implemented Safra's~\cite{1988_safra_2} and Muller and Schupp's~\cite{Muller199569} Büchi determinisation constructions (that can be used as the base for complementation) in a tool called OmegaDet and determinsed the Michel automata~\cite{michel1988} with 2 to 6 states. The result was that that Safra's construction produces smaller automata than Muller and Schupp's construction.

In 2008, Tsay et al.~\cite{2008_goal_ext} in \goal~\cite{2007_goal}\cite{2008_goal_ext}\cite{2009_goal}\cite{2013_goal}
compared Safra's construction~\cite{1988_safra_2}, Piterman's construction~\cite{2007_piterman}, Thomas's construction~\cite{1999_thomas} (WAPA), and Kupferman and Vardi's construction~\cite{Kupferman:2001} (WAA)

In 2009, Kamarkar and Chakraborty~\cite{2009_karmarkar} proposed an improvement of Schewe's complementation construction~\cite{schewe2009buchi} and implemented it, as well as Schewe's original construction, on top of the model checker NuSMV~\cite{1999_nusmv}\cite{2002_nusmv}. They ran the constructions on 12 test automata and compared the sizes of the output automata with each other. Furthermore, theay did the same tests with the constructions by Friedgut, Kupferman, and Vardi~\cite{Kupferman:2001} and Piterman~\cite{2007_piterman} that are pre-implemented in the \goal tool~\cite{2008_goal_ext}.


Regarding the state complexity of Büchi complementation constructions, only the worst-case state growths have been investigated. However, they are a poor guide to actual peformance of constructions~\cite{2011_tsai}. Need for empirical complexity investigations to see the \textit{actual} performance of complementation constructions.

\subsection{Aim and Scope}

Aim: empirical performance investigation of a specific Büchi complementaiton construction, comparison with other constructions

Scope: two test sets, relatively small automata, no real world or ``typical'' examples,

% Significance: advance knowledge, contribute to solutin of practical problem, novel use of a procedure or technique?

\subsection{Overview}


% 2. The Büchi complementation problem
% 2.1 Preliminaries
% Used naming convention (NBW, DBW, etc.)
%   2.1.1 Büchi automata
%     - Definition
%     - DBW vs. NBW
%     - Equivalence with omega-regular languages (NBW)
%     - DBW weaker than NBW (proof)
%   2.1.2 Other omega-automata
%     - Muller, Rabin, Streett, Parity
%     - McNaughton's Theorem (NBW = DMW)
%     - Complete picture of equivalences
%   2.1.3 Complementation of Büchi automata
%     - NBW closed under complementation (DBW not, proof)
%     - Example NFA/DFA
%     - Complementation of DBW (Kurshan)
%   2.1.4 Complexity of Büchi Complementation
%     - Notion of state blow-up
%     - Lower bounds for the state blow-up
% 2.2 Review of Büchi Complementation Constructions
% 2.3 Empirical Performance Investigations