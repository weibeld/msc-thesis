\lettrine{A}{t the beginning} of the 1960s, a Swiss logician named Julius Richard Büchi was searching a procedure for deciding the satisfiability of formulas of the monadic second order logic with one successor (S1S). In his quest, Büchi observed that an S1S formula can be represented by a certain type of finite state automaton running on infinite words, such that this automaton accepts a word representing an interpretation of the formula, if and only if the interpretation satisfies the formula. The proof of this equivalence between S1S formulas and this type of automata is known as \textit{Büchi's Theorem}. It led Büchi to his desired decision procedure: to test whether an S1S formula $\varphi$ is satisfiable, translate it to an equivalent automaton $A$, and test whether $A$ is empty (that is, accepts no words at all). If $A$ is empty, then $\varphi$ is unsatisfiable, if $A$ is non-empty, then $\varphi$ is satisfiable.~\cite{buchi1960decision}

This thesis is about the type of automata that Büchi invented in order to solve the satisfiability problem of S1S. These automata are called \textit{Büchi automata}. Büchi automata have important applications in logic-related domains. One of them is the automata-theoretic approach to model checking, a branch of formal verification. A property to verify is specified as a Büchi automaton. The test whether the system satisfies the property requires the \textit{complementation} of this Büchi automaton. Complementing a Büchi automaton $A$ means to construct another Büchi automaton $B$ that accepts a word if and only if it is not accepted by $A$. An algorithm that takes as input a Büchi automaton and outputs the complement of this automaton is called a \textit{Büchi complementation construction}.

Büchi complementation has a very high \textit{state complexity}. This means that, given a Büchi automaton, the complement produced by a complementation construction may be extremely large. This complexity inhibits the practical application of Büchi complementation, for example in automata-theoretic model checking~\cite{2007_vardi_model_checking, 2007_vardi}. For this reason, Büchi complementation is an active research topic since the introduction of Büchi automata more than 50 years ago.

The subject of this thesis is the investigation of the performance of a specific Büchi complementation construction, the \textit{Fribourg construction}. For this investigation, we take on an empirical approach. This means that we test the construction on a set of example automata in order to evaluate the output of the construction. Generally, the smaller the complement automata that a construction generates, the better the performance of this construction. Our aim is to contribute with our results to a better understanding of the problem of Büchi complementation.

% Büchi complementation constructions are an active research topic since the introduction of Büchi automata more than 50 years ago. The reason for this persistence is that these constructions exhibit a very high \textit{state complexity}. This means that, given a Büchi automaton, the complement produced by a complementation construction may be extremely large. This complexity inhibits the practical application of Büchi complementation~\cite{2007_vardi_model_checking, 2007_vardi}. For this reason, there is an ongoing quest to find more efficient Büchi complementation constructions, and to generally better understand the problem of Büchi complementation.

This introductory chapter is structured as follows. In Section~\ref{1_context}, we present the context in which the subject of this thesis is situated. It includes Büchi automata and the problem of Büchi complementation in general, and the applications and significance of Büchi complementation. In Section~\ref{1_motivation}, we motivate the empirical approach for increasing our understanding of Büchi complementation. In Section~\ref{1_aim_scope}, we clarify the aim and scope of the thesis. Finally, in Section~\ref{1_overview}, we present the structure of the rest of this document.


% The type of automaton that Büchi used for solving this logical problem is called \textit{Büchi automaton}. The application of Büchi automata to logic, that was established by Büchi, had a large impact on other fields, especially model checking, which is a technique of formal verification. In particular, Büchi automata allow to solve the model checking question automata-theoretically, which has many advantages~\cite{1996_vardi}.

% However, there is one operation on Büchi automata that is giving a ``headache'' to the research community since the introduction of Büchi automata more than 50 years ago, namely the problem of \textit{complementation}. Algorithms for carrying out this operation, although possible\footnote{Büchi himself has proved that Büchi automata are closed under complementation~\cite{buchi1960decision}.}, turn out to be very complex, in many cases too complex for practical application. Yet, Büchi complementation has a practical application in the automata-theoretic approach to model checking. This discrepancy led to an ongoing quest for finding more efficient \textit{Büchi complementation constructions}, and generally better understanding the complexity of Büchi complementation. The work in this thesis is situated in this area of research.


% - automata-theoretic approach to logic
% - Büchi's Theorem
%   - Proof includes proving that Büchi automata are closed under complementation (most difficult part).


% At the beginning of the 1960s, a Swiss logician named Julius Richard Büchi at Michigan University was looking for a way to prove the decidability of the satisfiability of monadic second order logic with one successor (S1S). Büchi applied a trick that truly founded a new paradigm in the application of logic to theoretical computer science. He thought of interpretations of a S1S formula as infinitly long words of a formal language and designed a type of finite state automaton that accepts such a word if and only if the interpretation it represents satisfies the formula. After proving that every S1S formula can be translated to such an automaton and vice versa (Büchi's Theorem), the satisfiabilty problem of an S1S formula could be reduced to testing the non-emptiness of the corresponding automaton.

% This special type of finite state automaton was later called Büchi automaton.

\section{Context}
\label{1_context}
In this section, we describe the context of Büchi complementation. To this end, we first briefly present Büchi automata and Büchi complementation in general (Section~\ref{1_buchi_automata}). Next, we present an application of Büchi complementation in formal verification (Section~\ref{1_application}). Finally, in Section~\ref{1_importance}, we highlight the importance of Büchi complementation for this application in formal verification.

\subsection{Büchi Automata and Büchi Complementation}
\label{1_buchi_automata}
Büchi automata are finite state automata that process words of infinite length, so called \om-words. If we denote by $\Sigma$ the alphabet of a Büchi automaton, then the set of all \om-words that can be generated from this alphabet is $\Sigma^\omega$. A word $\alpha \in \Sigma^\omega$ is accepted by a Büchi automaton $A$ if it has at least one accepting run in $A$. A run is accepting if it contains an infinite number of occurrences of at least one accepting state. A run of a Büchi automaton on a word is a possibly infinite sequence of states. Deterministic Büchi automata have at most one run for each word in $\Sigma^\omega$, whereas non-deterministic Büchi automata may have multiple runs for a word.

The complement of a Büchi automaton $A$ is another Büchi automaton\footnote{Büchi automata are closed under complementation. This has been proved by Büchi~\cite{buchi1960decision}. For the sake of this proof, Büchi described the first Büchi complementation in the history of Büchi automata.} that we denote by $\cl1{A}$. Both, $A$ and $\cl1{A}$, share the same alphabet $\Sigma$. Regarding a word $\alpha \in \Sigma^\omega$, the relation between an automaton $A$ and its complement $\cl1{A}$ is as follows:

\begin{quote}
\centering
\textit{$\alpha$ is accepted by $A$ $\Longleftrightarrow$ $\alpha$ is not accepted by $\cl1{A}$}
\end{quote}

That is, all the words of $\Sigma^\omega$ that are \textit{accepted} by an automaton are \textit{rejected} by its complement, and all the words of $\Sigma^\omega$ that are \textit{rejected} by an automaton are \textit{accepted} by its complement. In other words, there is no single word of $\Sigma^\omega$ that is  accepted or rejected by \textit{both} of an automaton and its complement.

The difficulty of constructing the complement for a given Büchi automaton depends on whether this automaton is deterministic or non-deterministic. The complementation of \textit{deterministic} Büchi automata is regarded as ``easy'', because there exists a construction that can do it in polynomial time and linear space (Kurshan's construction)~\cite{Kurshan198759}. The complementation of \textit{non-deterministic} Büchi automata, however, is very complex, and therefore subject of ongoing research. Note that when in the following we talk about ``Büchi complementation'' we always refer to the complementation of \textit{non-deterministic} Büchi automata.

The main problem with the complexity of Büchi complementation is the so-called \textit{state complexity} (also known as \textit{state growth}, \textit{state blow-up} or \textit{state explosion}). This is the number of states of the output automaton in relation to the number of states of the input automaton. In particular, this means that the complement of a given Büchi automaton may be extremely large. This hinders the practical application of Büchi complementation, because the complementation operation may require very high time and computing resources. In the following we describe an important application of Büchi complementation that is negatively affected by the high state complexity of Büchi complementation.

% The complementation of Büchi automata, in particular non-deterministic Büchi automata, is commonly known as ``Büchi complementation'' or the ``Büchi complementation problem''. It is a very complex problem because it exhibits a very high state growth, which is sometimes even called state explosion (in the following, we will use the terms state growth, state explosion, and state complexity interchangeably). State growth denotes the relation of the number of states of a complement $\cl1{A}$ (output of the complementation construction) to the number of states of the automaton $A$ (input to the complementation construction). This relation is for worst-case automata exponential, even for an ideal complementation construction\footnote{Yan proved in 2007 a lower bound for the worst-case state growth of Büchi complementation of $(0.76n)^n$, where $n$ is the number of states of the initial automaton~\cite{DBLP:journals/corr/abs-0802-1226}.}. Even though the state growth that existing complementation constructions produce for many non-worst-case automata is not nearly as high as the worst case, it may still be very high. This is a serious problem, because Büchi complementation has important practical applications (as we will see next), and it is the reason that the quest for more efficient and more practical Büchi complementation constructions is still an active research topic today.


\subsection{An Application of Büchi Complementation}
\label{1_application}
In this section, we describe a specific application of Büchi complementation in formal verification. To this end, we proceed in two steps. First, we describe a general application of Büchi complementation, namely testing language containment of \om-regular languages. Next, we describe how language containment is used in a specific formal verification approach, which is called language containment approach to automata-theoretic model checking. Thus, together these two descriptions show how Büchi complementation is used in this specific model checking approach.

The following elaborations touch on various model checking concepts. For a comprehensive treatment of the interesting topic of model checking, as well as other formal verification approaches, we refer to the works by Huth~\cite{huth2004logic}, Ben-Ari~\cite{ben2012mathematical}, and Baier~\cite{baier2008principles}.

\subsubsection{Language Containment of \om-Regular Languages}
Büchi complementation is used for testing language containment of \om-regular languages. The \om-regular languages are the class of formal languages that is equivalent to non-deterministic Büchi automata\footnote{Note that deterministic Büchi automata have a lower expressivity than non-deterministic Büchi automata, and are equivalent to only a subset of the \om-regular languages.}. An \om-regular language consists of \om-words (that is, infinite words) over an alphabet $\Sigma$.

Given two \om-regular languages $L_1$ and $L_2$ over alphabet $\Sigma$ the language containment problem consists in testing whether $L_1 \subseteq L_2$. This is true if all the words of $L_1$ are also in $L_2$, and false if $L_1$ contains at least one word that is not in $L_2$. The way this problem is algorithmically solved is by testing $L_1 \cap \cl1{L_2} = \varnothing$. Here, $\cl1{L_2}$ denotes the complement language of $L_2$, which means that $\cl1{L_2}$ contains all the words of $\Sigma^\omega$ that are \textit{not} in $L_2$. The steps for testing $L_1 \cap \cl1{L_2} = \varnothing$ are the following:

\begin{enumerate}
\item Create the complement language $\cl1{L_2}$ of $L_2$
\item Create the intersection language $L_{1,\cl1{2}}$ of $L_1$ and $\cl1{L_2}$
\item Test whether $L_{1,\cl1{2}}$ is empty (that is, contains no words at all)
\end{enumerate}

Thus, the language containment problem is reduced to three operations on languages: \textit{complementation}, \textit{intersection}, and \textit{emptiness testing}. A common way to work with formal languages is not to handle the languages themselves, but equivalent automata that represent them. In the case of \om-regular languages, these automata are non-deterministic Büchi automata.

Thus, solving $L_1 \subseteq L_2$ can be done with two Büchi automata $A_1$ and $A_2$ that represent $L_1$ and $L_2$, respectively. The problem then becomes $L(A_1) \subseteq L(A_2)$, and equivalently, $L(A_1) \cap \cl1{L(A_2)} = \varnothing$. This is automata-theoretically solved as $\text{\textsf{empty}}(A_1 \cap \cl1{A_2})$, which includes the following three steps:

\begin{enumerate}
\item Construct the complement automaton $\cl1{A_2}$ of $A_2$
\item Construct the intersection automaton $A_{1,\cl1{2}}$ of $A_1$ and $A_2$
\item Test whether $A_{1,\cl1{2}}$ is empty (that is, accepts no words at all)
\end{enumerate}

If the final emptiness test on automaton $A_{1,\cl1{2}}$ is true, then $L_1 \subseteq L_2$ is true, and if the emptiness test is false, then $L_1 \subseteq L_2$ is false. In this way, the language containment problem of \om-regular languages is reduced to three operations on non-deterministic Büchi automata: \textit{complementation}, \textit{intersection}, and \textit{emptiness testing}. Hence, Büchi complementation is an integral part for solving the language containment problem of \om-regular languages.

%  This means, we have to create the intersection language, say $L_{1,\cl1{2}}$ of $L_1$ and the complement of $L_2$, and then test whether $L_{1,\cl1{2}}$ is empty (that is, contains no words at all). If $L_{1,\cl1{2}}$ is empty, then there is no word of $L_1$ that is not also in $L_2$, and $L_1 \subseteq L_2$ is true. If $L_{1,\cl1{2}}$ is non-empty, then there is at least one word of $L_1$ that is not in $L_2$, and $L_1 \subseteq L_2$ is false.

% With this procedure, we in fact reduce the language containment problem to three operations on languages: complementation, intersection, and emptiness testing. By translating the languages $L_1$ and $L_2$ to equivalent automata $A_1$ and $A_2$, and mainpulating the automata instead of the languages, the problem becomes $L(A_1 \cap \cl1{A_2}) = \varnothing$. That is, we complement $A_2$, create the intersection automaton $A_{1,\cl1{2}}$ of $A_1$ and the complement of $A_2$, and test whether the language of $A_{1,\cl1{2}}$ is empty, which is done by directly testing the automaton $A_{1,\cl1{2}}$ for emptiness.

% In this way, we reduce the language containment problem of \om-regular languages to three operations on non-deterministic Büchi automata: complementation, intersection, and emptiness testing. Büchi complementation is thus an integral part of the language contaiment problem. However, this does not yet answer our initial question of what is a \textit{concrete} and \textit{practical} application of Büchi complementation. To answer this question, we will in the following describe one important application of langauge containment of \om-regular languages.


% One of the main applications of Büchi complementation is language containment of \om-regular languages. This means to find out whether all the words of a language $L_1$ are also contained in another language $L_2$, formally written as $L_1 \subseteq L_2$.

% The way this problem is solved is by testing $L_1 \cap \cl1{L_2} = \varnothing$. That is, one takes the intersection of the first (contained) language and the \textit{complement} of the second (containing) language, and tests whether this intersection is empty. If yes, then all the words of $L_1$ are also contained in $L_2$, and $L_1 \subseteq L_2$ is true. If no, then there is at least one word of $L_1$ that is not contained in $L_2$, and $L_1 \subseteq L_2$ is false.

% If we represent languages as automata, then the problem becomes $L(A_1) \subseteq L(A_2)$, which is solved by testing $L(A_1) \cap L(\cl1{A_2}) = \varnothing$. That means, we have to complement the automton $A_2$.


\subsubsection{Language Containment Approach to Automata-Theoretic Model Checking}
Above, we have seen that Büchi complementation is used for testing language containment of \om-regular languages. Now, we explain what language containment of \om-regular languages is used for. This application of language containment is called the the language containment approach to automata-theoretic model checking.

The language containment approach to automata-theoretic model checking is an approach to automata-theoretic model checking, which is an approach to model checking, which in turn is an approach to formal verification~\cite{2007_vardi_model_checking}. Figure~\ref{model_checking} shows the branch of the family of formal verification techniques that contains the language containment approach to automata-theoretic model checking.

\begin{figure}[htb]
\centering
\ModelChecking
\caption{Branch of the family of formal verification techniques that contains the language containment approach to automata-theoretic model checking.}
\label{model_checking}
\end{figure}

Formal verification is the use of mathematical techniques for proving the correctness of a system (software of hardware) with respect to a specified property~\cite{2007_vardi_model_checking}. A typical example is to verify that a program is deadlock-free (in which case the property would be ``deadlock-freeness''). In general, formal verification techniques consist of the following three parts~\cite{huth2004logic}:

\begin{itemize}
\item A framework for modelling the system to verify
\item A framework for specifying the property to be verified
\item A verification method for testing whether the system satisfies the property
\end{itemize}

For the language containment approach to automata-theoretic model checking, the frameworks that are used for the first two parts are \om-regular languages. These languages are represented by non-deterministic Büchi automata. The verification method consists in testing language containment of the language representing the system in the language representing the property~\cite{1996_vardi,2007_vardi_model_checking}. In the following we explain how this works in more detail.

The system $s$ to verify is expressed as a Büchi automaton $S$. This Büchi automaton represents an \om-regular language $L(S)$, and each word of $L(S)$ represents in turn a possible \textit{computation} of the system. A computation is an infinite\footnote{The infinity of computations suggests that this type of formal verification (and model checking in general) is used for systems that are not expected to terminate and  may run indefinitely. This type of systems are called \textit{reactive systems}. Reactive systems contrast with systems that are expected to terminate and produce a result. For this latter type of systems other formal verification techniques than model checking are used. See for example~\cite{huth2004logic} or~\cite{ben2012mathematical} for works that cover formal verification techniques for both types of systems.} sequence of ``situations'' that the system is in at any point in time. Such a situation consists of a finite amount of information of, for example, the values of variables, registers, or buffers. The observation that such a trace can be represented as a word of an \om-regular languages comes from the fact that it can be represented intuitively as a linear Kripke structure, which in turn can be represented by a word of a language whose alphabet is ranges over the powerset of the atomic propositions of the Kripke structure. A work that explains these intimate relations between computation, temporal logic, formal languages, and automata in more detail is~\cite{1996_vardi}. In simple words, the language $L(S)$, represented by the system automaton $S$, represents all the computations that the system \textit{can} do.

Similarly, a property $p$ to be verified is expressed as a Büchi automaton $P$, which represents the \om-regular language $L(P)$, whose words also represent computations. The set of computations represented by $L(P)$ are all the computations of a system like $s$ that satisfy the property $p$. If for example $p$ is ``deadlock-freeness'', then the words of $L(P)$ represent all the possible computations that do \textit{not} contain a deadlock. In this way, the language $L(P)$ represents all the computations that the system is \textit{allowed} to do, with respect to a certain property.

The verification step is finally done by testing the language containment $L(S) \subseteq L(P)$. If this is true, then every computation that the system \textit{can} do is \textit{allowed} to do, with respect to the property $p$, and the system satisfies the property $p$. If the language containment test is false, then there is a computation that the system \textit{can} that is \textit{not allowed} to do, with respect to the property $p$, and the system does not satisfy the property $p$.

This shows how the language containment approach to automata-theoretic model checking relies on the language containment problem of \om-regular langauges. As we have seen before, the language containment problem of \om-regular languages in turn relies on Büchi complementation. Hence, Büchi complementation is an integral part of this model checking approach.

%   with each state being a situation of the system.  . The observation that computation traces can be represented as words of an \om-regular language is in turn based on temporal logic. 

%  Each word of the language $L(S)$ of $S$ corresponds to a possible computation trace of the system $s$. A computation trace is an infinite sequence of ``combinations of properties'' of the system. Such properties can be for example variable values or statuses of individual processes. Each element of a computation trace corresponds to a point in time during the execution of the system. The language $L(S)$ represents thus everything that the system \textit{can} do.

% A property $p$ to be verified is represented as a non-deterministic Büchi automaton, say $P$. The words of the language $L(P)$ of $P$ also represent computation traces. In particular, the language $L(P)$ represents all the possible computation traces that do satisfy the property $p$. If for example $p$ is ``deadlock-freeness'', then $L(P)$ contains all the possible computation traces of a system like $s$ that are deadlock-free. In other words, the language $L(P)$ represents everything that a system is \textit{allowed} to do, with respect to a property $p$.

% The verification step then consists in testing $L(S) \subseteq L(P)$, that is, whether everything that the system \textit{can} do is contained in everything that the system is \textit{allowed} to do. If this is true, then every possible computation trace of the system satisfies the property $p$, because it is contained in $L(P)$. If $p$ means deadlock-freeness, then we can conclude that the system is deadlock-free. If the language containment test returns a negative result, then there must be at least one computation trace of the system that does not satisfiy the property $p$, because it is not in $L(P)$. In that case, this computation trace (however improbable it is), for example, leads to a deadlock, and we have to conclude that the system is not deadlock-free.

% This short description points out the application of language containment in formal verification, and, as we know, language containment of \om-regular languages requires Büchi complementation. In the following, we will briefly mention some interesing points about the specific role of Büchi complementation in automata-theoretic model checking.

\subsection{Importance of Büchi Complementation}
\label{1_importance}
The high complexity of Büchi complementation makes the language containment approach to automata-theoretic model checking inapplicable in practice~\cite{1995_tasiran}. According to~\cite{2007_vardi_model_checking} and~\cite{2007_vardi}, there are so far no model checking tools that include the complementation of a property Büchi automaton. This is unfortunate, because the other operations for the language containment test, intersection and emptiness testing, have highly efficient solutions for Büchi automata~\cite{1996_vardi,2007_vardi_model_checking}. Büchi complementation is thus a bottleneck. Existing model checking applications are forced to circumvent the need for Büchi complementation. In the following, we explain how this can be done, and why the approach via the complementation of non-deterministic Büchi automata is preferable.

One way to circumvent the complementation of non-deterministic Büchi automata is to specify the property as a deterministic Büchi automaton~\cite{1995_tasiran,2007_vardi_model_checking}. As we have mentioned, the complementation of deterministic Büchi automata has an efficient solution. However, the disadvantage of this approach is that the property automaton may become exponentially larger than an equivalent non-deterministic automaton~\cite{1995_tasiran}. Furthermore, it is often more complicated and less intuitive to represent a property as a deterministic automaton~\cite{1995_tasiran}.

Another way to elude the need for Büchi complementation is to use a different model checking approach altogether. This leads us back to the basic model checking question. In basic model checking, the property to be verified is represented as a formula $\varphi$ of a temporal logic (typically LTL). The system to verify is represented as a Kripke structure $K$. Kripke structures are interpretations of temporal logic formulas. The verification step consists in checking whether $K$ satisfies $\varphi$, or in other words, whether $K$ is a model of $\varphi$ (written as $K \models \varphi$). This check of modelhood is the reason why \textit{model checking} is called this way~\cite{1996_vardi}.

The different model checking approaches differ in how they do the modelhood test. In the automata-theoretic approach, modelhood is tested in terms of automata. This is indeed possible \textit{without} the need for Büchi complementation~\cite{2007_vardi_model_checking}, as we explain in the following. The first step is to translate the Kripke structure $K$ to a Büchi automaton $A_K$. Regarding the formula $\varphi$, the crucial point is that it is not directly translated to a Büchi automaton, but that it is first negated to $\neg\varphi$, and only then translated to a Büchi automaton $A_{\neg\varphi}$. This allows to do the language containment test $L(K) \subseteq L(\varphi)$ (which is equivalent to the modelhood test $K \models \varphi$), as $\text{\textsf{empty}}(A_K \cap A_{\neg\varphi})$, that is, without the need for  complementing a Büchi automaton. This is because $A_{\neg\varphi}$ already represents the \textit{negation} of the property, and thus it is not necessary to complement this automaton. In this way, the negation of the property, which is required for the language containment test, is pushed off from Büchi automata to temporal logic formulas, in which case it is easy. This approach is used  by the SPIN model checker~\cite{1997_spin}. The disadvantage is that the typically used temporal logic, LTL, is less expressive than Büchi automata. Hence, specifying a property as an LTL formula restricts the set of properties that can be used. It has even been stated that the expressivity of LTL is often insufficient for industrial applications~\cite{2007_vardi_model_checking}.

The disadvantages of these alternative approaches highlight the importance of Büchi complementation for model checking. It shows that having more efficient Büchi complementation constructions, and to generally better understand the Büchi complementation problem, in order to handle it more adequately, would be of great practical value. In the next section, we motivate our empirical approach to contribute to a better understanding of Büchi complementation.


% One of them is to use a deterministic, rather than a non-deterministic, Büchi automaton for representing the property~\cite{1995_tasiran}\cite{2007_vardi_model_checking}. This is because the complementation of determinstic Büchi automata is easy (it can be done in polynomial time and linear space~\cite{Kurshan198759}). This has however the disadvantage that the resulting deterministic automaton may be considerably bigger than an equivalent non-deterministic automaton, and that it is generally more complicated and less intuitive to specify a property as a deterministic automaton~\cite{1995_tasiran}.

%  no verification tools that include the complementation of a non-deterministic property automaton, because of the sheer time and computing resources that it entails.


% As we have seen in the previous section, solving the language containment problem $L(S) \subseteq L(P)$ is done by translating it to the automata-theoretic problem $L(S \cap \cl1{P}) = \varnothing$, which in turn is solved by the following three steps:

% \begin{enumerate}
% \item Construct the \textit{complement} $\cl1{P}$ of the property automaton $P$
% \item Construct the \textit{intersection} automaton, say $A_{S,\cl1{P}}$, of $S$ and $\cl1{P}$
% \item Test $A_{S,\cl1{P}}$ for \textit{emptiness}
% \end{enumerate}

% The formal verification problem is thus reduced to three operations on Büchi automata, \textit{complementation}, \textit{intersection}, and \textit{emptiness testing}. Complementation is clearly the problem child of this triple. For intersection and emptiness testing of Büchi automata there exist efficient solutions~\cite{2007_vardi_model_checking} (cf.~\cite{1996_vardi}). Büchi complementation, however, is so complex that it makes the entire approach impractical~\cite{1995_tasiran}. According to~\cite{2007_vardi_model_checking}, there are so far no verification tools that include the complementation of a non-deterministic property automaton, because of the sheer time and computing resources that it entails.

% Instead, verification tools apply different ways to circumvent the need for complementing non-deterministic property automata. One of them is to use a deterministic, rather than a non-deterministic, Büchi automaton for representing the property~\cite{1995_tasiran}\cite{2007_vardi_model_checking}. This is because the complementation of determinstic Büchi automata is easy (it can be done in polynomial time and linear space~\cite{Kurshan198759}). This has however the disadvantage that the resulting deterministic automaton may be considerably bigger than an equivalent non-deterministic automaton, and that it is generally more complicated and less intuitive to specify a property as a deterministic automaton~\cite{1995_tasiran}.

% Another way to cirvumvent the need for Büchi complementation is to use a slightly different approach to automata-theoretic model checking (in Figure~\ref{model_checking}, a sibling of the language containment approach)~\cite{2007_vardi_model_checking}. In this approach, the property is not specified as a Büchi automaton, but as a linear temporal logic (LTL) formula $\varphi$. The formula $\varphi$ is then negated ($\neg\varphi$) and translated to a Büchi automaton $A_{\neg\varphi}$. If $A_S$ is the system automaton, then the verification step is done by testing $L(A_S \cap A_{\neg\varphi}) = \varnothing$. This works because $A_{\neg\varphi}$ is equivalent to $\cl1{A_{\varphi}}$, that is, the complement of the automaton representing the property. In this way we push off complementation from Büchi automata to LTL formulas, in which case it is trivial. A verification tool that uses this approach is the SPIN model checker~\cite{1997_spin}. The disadvantage of this approach is that LTL is less expressive than Büchi automata, and thus allows to express fewer properties. It has even been stated that the set of properties that can be expressed with LTL is unsufficient for industrial applications~\cite{2007_vardi_model_checking}.

% Summarising, we can say that automata-theoretic model checking is possible without Büchi complementation. However, the language containment approach with the direct specification of the property as a non-deterministic Büchi automaton has important practical advantages. Thus, finding more efficient ways for the complementation of non-deterministic Büchi automata would be of high practical value~\cite{2007_vardi_model_checking}. This motivates the fundamental topic of this thesis. In the next sections, we will see how our work specifically contributes to this quest.


\section{Motivation}
\label{1_motivation}
In the previous section we have seen that Büchi complementation is complex, and that it would be of great practical value to better understand it. In this section, we highlight the benefits of looking at Büchi complementation from an empirical rather than theoretical point of view. This can be done, for example, by empirically investigating the performance of Büchi complementation constructions.

In Section~\ref{1_theoretical}, we present the traditional way of assessing the performance of complementation constructions, which is is based on theoretical rather than empirical grounds. In Section~\ref{1_empirical}, we present and motivate the empirical approach, which this thesis is following. This includes a review of the empirical research on Büchi complementation that has been done to date.

\subsection{Theoretical Investigation of Worst-Case Performance}
\label{1_theoretical}
The traditional to assess the performance of Büchi complementation constructions is to identify their \textit{worst-case} state complexity. This is the state complexity a construction exhibits for a theoretical worst-case automaton. In other words, it means the maximum number of states a construction can generate.

For example, the original complementation construction by Büchi~\cite{buchi1960decision} has a doubly-exponential worst-case state complexity of $2^{2^{O\left(n\right)}}$. At this point, two remarks. First, a state complexity is given as a function of the number $n$ of states of the input automaton. Second, the state complexity often include terms with the big-$O$ notation. When we need to assume exact functions for examples, we simply ignore the big-$O$ notation. This worst-case state complexity of Büchi's construction means that, given an input automaton with $n$ states, the complement cannot have more than $2^{2^{O\left(n\right)}}$ states. For example, if the input automaton has 8 states, then the upper bound for the number of states of the complement is $1.16 \times 10^{77}$ (if assuming the concrete function $2^{2^n}$).

Different constructions exhibit different worst-case state complexities, and one of the main objectives of construction developers is to reduce this number. For example, the more recent construction that Schewe proposed in 2009~\cite{schewe2009buchi} has a worst-case state growth of only $O((0.76n)^nn^2)$. For an input automaton with 8 states, this means that the complement has at most 119.5 million states. This is a tremendously smaller number than the maximum number of states of Büchi's construction.

A related track of research is concerned with finding universal lower bounds for the worst-case state complexity of Büchi complementation constructions. This can be done by proving that there are certain automata whose complements  have \textit{at least} a certain number of states. Consequently, no complementation construction can have a worst-case state complexity that is below this number. A first such lower bound of $n!$ has been proposed in 1988 by Michel~\cite{michel1988}. He proved that there exists a family of automata whose complement have at least $n!$ states. These automata are known as Michel automata. Later, in 2007, Yan~\cite{DBLP:journals/corr/abs-0802-1226} proved that there are automata whose minimum complement size is even larger than $n!$, namely $(0.76n)^n$ (Michel's $n!$ lower bound corresponds to approximately $(0.36n)^n$~\cite{DBLP:journals/corr/abs-0802-1226}). This means that $(0.76n)^n$ replaces $n!$ as a new lower bound for the worst-case state complexity of Büchi complementation. This lower bound is valid until today.

Generally, construction developers aim at brining the worst-case state complexity of their construction close to this lower bound. For example, Schewe's construction is very close to the lower bound of $(0.76n)^n$~\cite{schewe2009buchi}. If the worst-case state complexity of a construction matches this lower bound, it is said to be \textit{optimal}. Note that the worst-case state complexity of a specific construction constitutes an upper bound for the general worst-case state complexity of Büchi complementation. This is because the currently valid lower bound cannot rise higher than the worst-case state complexity of a known construction. Therefore, new constructions with lower worst-case state complexities can be seen as narrowing the gap between the upper and lower bound of the exact state complexity bound of Büchi complementation.

\subsection{Empirical Investigation of Actual Performance}
\label{1_empirical}
Worst-case state complexities are interesting from a theoretical point of view. However, they are not necessarily good guides to the actual performance of a construction~\cite{2011_tsai}. For example, if we have a concrete automaton of, say, 15 states, and we complement it with Schewe's construction, the fact that the worst-case state complexity is $(0.76n)^n n^2$ reveals that the complement has in the worst case 1.6 quintillion ($1.6 \times 10^{18}$) states. However, in a practical case, we do not anticipate the worst case, but we are rather interested in the performance on a more likely ``average case''.

In a practical application of Büchi complementation, we could be interested in questions about complementation constructions as follows; what is a reasonable complement size to expect for the given automaton with $n$ states? Are there generally easier and harder automata? What are the factors that make an automaton especially easy or hard? How does the performance of different constructions on the same automata vary? Are there constructions which are better suited for a certain type of automata than other constructions?

% Furthermore, if a construction has a higher worst-case state complexity than another, it does not mean that it performs worse on a concrete case. In fact, worst-case state complexities only allow to adequately deduce the performance on the specific worst-case automata, but not on all the other automata. However, from a practical point of view, these worst cases are not interesting, as their application in practice is anyway infeasible~\cite{1995_tasiran} (at least starting from a certain input automaton size).

% From a practical perspective we are interested how constructions perform on automata as they could occur in a concrete application of Büchi complementation, such as automata-theoretic model checking. This may include questions like the following. 

Questions like this cannot be answered by theoretical investigations of the worst-case state complexity of the constructions. However, they can be attempted to answer by empirical performance investigations of these constructions. With empirical performance investigations, we mean the testing of a construction with concrete automata, and the analysis of the results that the construction produces. Naturally, such investigations are based on an \textit{implementation} of the investigated constructions and on \textit{test data}, that is, the set of automata with which the constructions are tested.

There have been relatively few empirical investigations~\cite{2011_tsai}, compared to the number of theoretical works. What follows is a short review some of these empirical works that have been done in the past. This illustrates the empirical approach, and presents the line of research in which this thesis is situated.

Note that in the following review we mention many complementation constructions. All of these constructions will be presented in our review of Büchi complementation constructions in Chapter~\ref{chap_background}. Furthermore, we indicate whether a construction is Ramsey-based, determinisation-based, rank-based, or slice-based. These are the main complementation approaches that we also explain in Chapter~\ref{chap_background}. 

{\setlist[description]{leftmargin=0.5cm, itemsep=\parskip}
\begin{description}
\item[1995] Tasiran et al.~\cite{1995_tasiran} create an efficient implementation of Safra's construction\cite{1988_safra_2} (determinisation-based) and used it for for automata-theoretic model checking tasks with the HSIS verification tool~\cite{1994_hsis}. They state that they could easily complement property automata with some hundreds of states, however, they do not provide a statistical evaluation of the results.

\item[2003] Gurumurthy et al.~\cite{2003_Gurumurthy} implement Friedgut, Kupferman, and Vardi's construction~\cite{Kupferman:2001} (rank-based) along with various optimisations that they propose as a part of the tool Wring~\cite{somenzi2000efficient}. They complement 1,000 small automata, generated by translation from LTL formulas, and evaluate execution time, and number of states and transitions of the complement for the different versions of the construction.

\item[2006] Althoff et al.~\cite{2006_althoff} implement Safra's~\cite{1988_safra_2} and Muller and Schupp's~\cite{Muller199569} determinisation constructions\footnote{These determinisation constructions transform a non-deterministic Büchi automaton to a deterministic Rabin automaton (see Section~\ref{2_om-automata}), however, the are used as the base for determinisation-based complementation constructions.} in a tool called OmegaDet, applied them on the Michel automata with 2 to 6 states, and compared the number of states of the determinised output automata.

\item[2008] Tsay et al.~\cite{2008_goal_ext} carry out a first comparative experiment with the publicly available\footnote{\url{http://goal.im.ntu.edu.tw/wiki/doku.php}} \goal{} tool~\cite{2007_goal,2008_goal_ext,2009_goal,2013_goal}. They include the constructions by Safra~\cite{1988_safra_2} (determinisation-based), Piterman~\cite{2007_piterman} (determinisation-based), Thomas~\cite{1999_thomas} (WAPA\footnote{Via weak alternating parity automaton}), and Kupferman and Vardi\cite{Kupferman:2001} (rank-based and WAA\footnote{Via weak alternating automaton}). These constructions are pre-implemented in \goal. As the test data, they use 300 Büchi automata, translated from LTL formulas, with an average size of 5.4 states. They evaluate and compare execution times, as well as number of states and transitions of the complements.

\item[2009] Kamarkar and Chakraborty~\cite{2009_karmarkar} propose an improvement of Schewe's construction~\cite{schewe2009buchi} (rank-based) and implement it, as well as Schewe's original construction, on top of the model checker NuSMV~\cite{1999_nusmv,2002_nusmv}. They run the constructions on 12 test automata and compare the sizes of the complements. Furthermore, they run the same tests with the constructions by  Kupferman and Vardi~\cite{Kupferman:2001} (rank-based or WAA) and Piterman~\cite{2007_piterman} (determinisation-based) within \goal, and compare the results to the ones of their implementation of Schewe's construction.

\item[2010] Tsai et al.~\cite{2011_tsai} (paper entitled ``State of Büchi Compelentation'') carry out another study with \goal. They compare the constructions by Piterman~\cite{2007_piterman} (determinisation-based), Schewe~\cite{schewe2009buchi} (rank-based), and Vardi and Wilke~\cite{vardi2007automata} (slice-based), with various optimisations that they propose in the same paper. As the test data, they use 11,000 randomly generated automata with 15 states and an alphabet size of 2. The test set is organised into 110 automata classes that consist of the combinations of 11 transition densities and 10 acceptance densities. This test set is repeatedly used in subsequent work (including in this thesis), and we will refer to it as the \goal{} test set (because it has been generated with the \goal{} tool). Tsai et al. provide sophisticated evaluation of the states of the complements for all the tested constructions and construction versions.

\item[2010] Breuers~\cite{2010_breuers_bsc} proposes an improvement for the construction by Sistla, Vardi, and Wolper~\cite{PrasadSistla1987217} (Ramsey-based), and creates an implementation of it. He generates his own test data (inspired by test data used by Tsai et al.~\cite{2011_tsai}) consisting of \textit{easy}, \textit{medium}, and \textit{hard} automata, based on different transition density and acceptance density values. He evaluates the complement sizes produced by the construction for automata of sizes 5, 10, and 15 of all these difficulty categories.

\item[2012] Breuers et al.~\cite{2012_breuers} wrap the implementation of their improvement of Sistla, Vardi, and Wolper's construction~\cite{PrasadSistla1987217} in the publicly available tool Alekto\footnote{\url{http://www.automata.rwth-aachen.de/research/Alekto/}}, and and run it on the \goal{} test set. They compare the generated complement sizes, as well as the number of aborted complementation tasks (due to exceeding resource requirements) to the results by Tsai et al.~\cite{2011_tsai}.

\item[2013] Göttel~\cite{2013_bsc_goettel} creates a C implementation of the Fribourg construction~\cite{2014_joel_ulrich}, including the R2C optimisation (see Chapter~\ref{chap_construction}), and executes it on the \goal{} test set, as well as on the Michel automata with 3 to 6 states. He evaluates the resulting complement sizes and execution times separately for each of the 110 transition density/acceptance density classes that the \goal{} test set consists of. The Fribourg construction is a slice-based complementation construction that is being developed at the university of Fribourg, and which is the subject of the empirical performance investigation of this thesis.
\end{description}}


\section{Aim and Scope}
\label{1_aim_scope}
The aim of this thesis is to contribute to a better understanding of Büchi complementation. Our approach is to empirically investigate the performance of a specific Büchi complementation construction, the Fribourg construction. In this way, we follow up on the line of empirical research that we have outlined in the last section. From the results that we obtain from our empirical study, we try to gain insights into Büchi complementation in general. Such insights can be targeted at questions like: what is an expectable output of a Büchi complementation construction given a specific input automaton? Is it possible to predict whether an automaton is likely to be a hard complementation task (that is, resulting in a large complement), or an easy complementation tasks (that is, resulting in a small complement) for a specific construction, or in general? Are there relative strengths and weaknesses between constructions?

This thesis is certainly not sufficient to provide such insights in a universal or conclusive way. Büchi complementation is a very complex topic and the current state of knowledge about it is relatively small. Rather, we see the contribution of this thesis as a mosaic stone that we add to the whole picture of Büchi complementation. We hope that the work presented in this thesis can serve as a base for findings and inspirations for future research, and in this way contribute to more mosaic stones being added to the picture of Büchi complementation.

% Significance: advance knowledge, contribute to solutin of practical problem, novel use of a procedure or technique?

\section{Overview}
\label{1_overview}
The remainder of this thesis consists of six more chapters. Chapter~\ref{chap_background} presents the background that is needed for the subsequent chapters. It presents Büchi automata, as well as other types of \om-automata, explains different run analysis techniques (which are an integral part of many complementation constructions), and reviews the most important Büchi complementation construction that have bee proposed during the past 50 years. Chapter~\ref{chap_construction} is dedicated to the Fribourg construction. It explains in detail how the construction and its optimisations work. In Chapter~\ref{chap_investigation}, we present the empirical study that we carry out. It includes the presentation of our implementation of the Fribourg construction, the used test data, and the test setups. In Chapter~\ref{chap_results}, we present the results of our empirical study. This includes a discussion of the gained insights and the limitations of the study. Finally, we conclude the thesis in Chapter~\ref{chap_conclusions}.

Note that there are three appendices. Appendix~\ref{app_plugin} explains how the plugin containing our implementation of the Fribourg construction is obtained and installed. Appendices~\ref{app_matrices} and~\ref{app_times} contain auxiliary data that are related to Chapter~\ref{chap_results}.



% \subsubsection{Worst-Case State Growth as Main Performance Measure} 
% Since the introduction of Büchi automata in 1962, many different Büchi complementation constructions have been proposed (see our review in Section~\ref{2_constructions}). The main performance measure for these constructions has usually been their so-called \textit{worst-case state growth} or \textit{worst-case state complexity} (in the following, we will use these two terms interchangeably\footnote{Further terms used in the literature are state blow-up or state explosion.}).

% State growth basically denotes the number of states of the output automaton in relation to the number of states of the input automaton to a complementation construction. Each automaton has thus its specific own state growth with each construction. The worst-case state growth of a construction results from a theoretical worst-case automaton, which has a higher state growth than any other automaton. In different words, the worst-case state growth is the maximum number of states that a concstruction \textit{can} generate.

% The state growth and the resulting time and space complexity is the biggest issue of Büchi complementation. The worst-case state growth seems to ``distill'' this issue to a single number which is practical to use as a concise performance measure and to compare different constructions with each other. Thus, much of the research effort in Büchi complementation construction has gone into reducing the worst-case state growth.

% For example, the complementation construction that has been described in 1962 by Büchi himself~\cite{buchi1960decision} has a doubly exponential worst-case state growth of $2^{2^{O\left(n\right)}}$, where $n$ is the number of states of the input automaton\footnote{In the following, we will always notate state growths as a function of $n$, and $n$ will always be the number of states of the input automaton.}. Note that worst-case state growths are often not given as exact functions, but include the big O notation. A later construction from 1987 by Sistla, Vardi, and Wolper~\cite{PrasadSistla1987217} reduces this worst-case state complexity to a singly exponential funtion of $O\left(2^{4n^2}\right)$. More recently, a construction from 2006 by Friedgut, Kupferman and Vardi from 2006~\cite{friedgut2006buchi} has a worst-caste state complexity of only $(0.96n)^n$.

% In parallel to the quest for complementation constructions with a low worst-case state complexity, there is a quest for finding the worst-caste state complexity of Büchi complementation itself. This is done by showing a theoretical minimum state growth of certain automata which even an ideal complementation construction could not undermatch. In this way, one proves a \textit{lower bound} for the worst-case complexity of Büchi complementation (it is still possible that there exist automata with an even higher theoretical minimum state growth). In 1988 Michel proved  such a lower bound of $n!$~\cite{michel1988} (in a different notation approximately $(0.36n)^n$). In 2008, Yan proved a new lower bound of $(0.76n)^n$~\cite{DBLP:journals/corr/abs-0802-1226}. This result is still valid at the time of this writing.

% A lower bound of $(0.76n)^n$ means that no complementation construction can ever have a worst-case state growth lower than $(0.76n)^n$. Consequently, a construction that achieves this worst-case state growth is commonly regarded as ``optimal''. 

% \subsubsection{Importance of Empirical Performance Investigations}
% Worst-case state growths are certainly interesting from a theoretical point of view. However, they can be seen as only one aspect of the performance of Büchi complementation constructions. The reality is certainly much more complex. If, for example, one is interested in practical questions (like how does a construction peform on a concrete automaton?), then worst-case state growths are a poor guide to the concrete performance of the construction~\cite{2011_tsai}.

% For example, if we have a concrete automaton, then the worst-case state growth does not reveal anything about how big the complement of this concrete automaton will be. It is not even clear whether in a concrete case a construction with a lower worst-case state growth produces a smaller complement than a construction with a higher worst-case state growth.

% Worst-case state growths are mainly meaningful for the worst cases. However, if these worst cases would occur, then all constructions would be far from practical anyway~\cite{1995_tasiran}. If we take for example Friedgut, Kupferman, and Vardi's construction~\cite{friedgut2006buchi} with a worst-case complexity of $(0.96n)^n$, Sistla, Vardi, and Wolper's construction with a worst-case complexity of $O\left(2^{4n^2}\right)$, and a ``worst-case'' automata of, say, 15 states, then the complements of the two constructions would have $2.73 \times 10^17$ (23.7 million billion) and $8.45 \times 10^270$ states, respectively. While this difference is still huge, in practice this does not matter much, because both cases are most likely anyway not feasible in practice.

% Hence, with regard to the practical application of Büch complementation (see Section~\ref{1_context}), we believe that it is important to investigate the \textit{actual} performance of Büchi complementation constructions on \textit{concrete} input automata. This is done by \textit{empirical} performance investigations that includes an implementation of the investigated construction, and a set of test data.







% 2. The Büchi complementation problem
% 2.1 Preliminaries
% Used naming convention (NBW, DBW, etc.)
%   2.1.1 Büchi automata
%     - Definition
%     - DBW vs. NBW
%     - Equivalence with omega-regular languages (NBW)
%     - DBW weaker than NBW (proof)
%   2.1.2 Other omega-automata
%     - Muller, Rabin, Streett, Parity
%     - McNaughton's Theorem (NBW = DMW)
%     - Complete picture of equivalences
%   2.1.3 Complementation of Büchi automata
%     - NBW closed under complementation (DBW not, proof)
%     - Example NFA/DFA
%     - Complementation of DBW (Kurshan)
%   2.1.4 Complexity of Büchi Complementation
%     - Notion of state blow-up
%     - Lower bounds for the state blow-up
% 2.2 Review of Büchi Complementation Constructions
% 2.3 Empirical Performance Investigations