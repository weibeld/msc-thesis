In this chapter we describe the Fribourg construction, the B체chi complementation construction developed at the University of Fribourg by Joel Allred and Ulrich Ultes-Nitsche. The construction has been published in 2014 as a technical report entitled ``Complementing B체chi Automata with a Subset-tuple Construction''~\cite{2014_joel_ulrich}.

We do not give a formal description of the Fribourg construction in this chapter, because this has already been done in~\cite{2014_joel_ulrich}. Rather, our aim is to give an intuitive and practically oriented description. That means, demonstrating the concrete steps one has to do when sitting with a pencil in front of an automaton to be complemented. Similarly, this chapter does not contain any proofs of the correctness or complexity of the constructions, because they can be found in~\cite{2014_joel_ulrich}.

This chapter is structured as follows. In Section~\ref{3_basics} we present some basic properties of the Fribourg construction and put it in relation with other complementation constructions. In Section~\ref{3_construction}, we describe the actual construction which consists of two stages, the construction of the upper part and the construction of the lower part. We present these two stages in separate sections, together with an example. Finally, in Section~\ref{3_optimsations}, we describe three optimisations for the construction, that have the abbreviations R2C, M1, and M2. These optimisations will also be subject to our empirical performance investigation that we describe in the subsequent chapter.

A note on terminology: the authors themselves call their construction ``subset-tuple construction''. This is because a state of the output automaton consists of a tuple of subsets of states of the input automaton. However, this is also the case for other constructions. To make our construction more distinguishable from the other constructions, we decided to use the more striking name ``Fribourg construction''.

\section{Basics}
\label{3_basics}
The Fribourg construction is a \textit{slice-based} complementation construction. That means that, like the other constructions of the slice-based approach (see Section~\ref{2_slice-based}), it is based on reduced split trees. Furthermore, it works in a subset-construction manner, that is, the output automaton is constructed state-by-state, by starting from an initial state.

The output-states are internally structured as tuples of subsets of input-states (each state consists of one tuple). The subsets of a tuple are pairwise disjoint, that is, no tuple contains two times the same input-state. The input-states of a tuple are the same as in the subset construction. The difference to the subset construction is that the input-states are not all in the same set, but distributed over multiple sets. Furthermore, the order of these sets in the tuple matters. As a convention, we will refer to the subsets contained by a tuple of an output-state as the \textit{components} of this output-state.

The components output-states are determined by levels of reduced split trees. According to the terminology of Vardi and Wilke~\cite{vardi2007automata}, we call these levels \textit{slices}. Figure~\label{slices} shows how slices of a reduced split tree determine output-states of the Fribourg construction. The relation works also in the other direction, that is, an output-state of the Fribourg construction determines a slice of a reduced split tree. The simple rule is that each vertex of a slice becomes a component in in the tuple of the output-state, and the order of the vertices is preserved.

\begin{figure}[htb]
\centering
\Slices
\caption{Translation from slices of a reduced split tree (shaded boxes on the left) to output-states of the Fribourg construction (right), and vice versa.}
\label{slices}
\end{figure}

This relation between slices of reduced split trees and output-states determines the basic working of the Fribourg construction. It works as follows. Start with an initial output-state containing only the initial input-state in its tuple. This state will be the current state. Translate the current state to a level of a reduced split tree, and, according to the input automaton, determine the next level of the reduced split tree for the first alphabet symbol, say $a$. Translate this new level back to an output-state, and set it as the $a$-successor of the current state. Repeat this procedure for all alphabet symbols, until the current state has a successor for each one. Finally, repeat the entire procedure for each output-state that has no successors yet. As in the subset construction, if a successor state happens to be identical to an already existing state, then just add a transition to this existing state.

What we just described is the very basic working of the Fribourg construction. However, there are additional details. First, there are two passes of this subset-construction-like procedure. The first one results in the so-called \textit{upper part} of the final complement automaton. The second one is applied on the states of the upper part (and all the newly created states), and results in the so-called \textit{lower part} attached to the upper part. These two parts together form the final complement automaton. The terminology ``upper'' and ``lower'' results from the fact that, when doing the construction by hand, the lower part is typically drawn below the upper part.

This distinction between upper and lower part is inspired by Kurshan's construction for complementing deterministic B체chi automata~\cite{Kurshan198759}. In fact, Kurshan's construction is a special case of the Fribourg construction~\cite{2014_joel_ulrich}.

The upper part of the Fribourg construction does not contain any accepting states. The lower part, in turn, may contain accepting states. A run of the final complement automaton starts in the upper part, and has in each upper-part state the non-deterministic choice to move to the lower part. Once in the lower part, a run cannot return to the upper part anymore. Semantically, the upper part represents anything that can happen in a finite prefix of an \om-word, and the lower part takes care of the infinite behaviour on \om-words.

The fact that the lower part determines the acceptance of a run, requires additional sophistication. This is achieved by the decoration of components. All components of the lower-part states are decorated with one of the three colours 0, 1 and 2. The colour of a component is determined by two things. First, whether the component is accepting or non-accepting. Second, the colour of its predecessor component. The predecessor component $c_{pred}$ of a component $c$ is the component of the predecessor state, that, in terms of reduced split trees, is the parent vertex of the vertex corresponding to component $c$.

Figure showing predecessor component relation

This colouration of components in the lower part requires that during the construction of the lower part, we keep track of two properties of each component. First, whether it is accepting or non-accepting, and second, its predecessor component (or just the colour of its predecessor component).

On a more general note, the Fribourg construction uses a similar idea as Vardi and Wilke's slice-based construction from 2007~\cite{vardi2007automata}. The upper and lower part of the Fribourg construction correspond to the \textit{initial phase} and \textit{repetition phase} of Vardi and Wilke's construction. Furthermore, the colours 0, 1, and 2 of the Fribourg construction correspond to the decorations \textit{inf}, \textit{new}, and \textit{die} of Vardi and Wilke's construction. However, the two constructions still differ in details, especially in the transition from the upper part to the lower part. In any case, the Fribourg construction has been developed independently and is not based on Vardi and Wilke's construction. Rather, the development of the Fribourg construction was based on Kurshan's construction for complementing DBW, which is to the best of our knowledge, not the case for Vardi and Wilke's construction.

Another difference is that the Fribourg construction uses right-to-left reduced split trees, whereas Vardi and Wilke's construction (as well as K채hler and Wilke's construction~\cite{2008_kaehler}) uses left-to-right reduced split trees. This is howevrer an arbitrary choice, and it has no effect on the final complement automaton. It would be possible to describe the Fribourg construction with left-to-right reduced split trees, and Vardi and Wilke's construction with right-to-left reduced split trees. In this thesis, we will stick with the right-to-left reduced split trees for the Fribourg construction.

By using reduced split trees, we consider only greedy runs on prefixes of words. That is, if two or more runs on the same words are after a certain number of steps in the same state, then only one of them is considered, the others are omitted. 


\section{The Construction}
\label{3_construction}
In this section, we describe the Fribourg construction in some more detail, and we illustrate its application with an example. 


\subsection{Upper Part}

\subsubsection{Description}
The construction of the upper part is simple and works basically as described above. We start with an initial output-state containing only a single component with the initial state of the input automaton. Then, for each output-state $q$ that has no successors so far, we creat a successor slice for each symbol of the alphabet $\alpha$, translate it to a state, and set it as the $\alpha$-successor of $q$. This is repeated until all states have a been processed.

In case that the resulting automaton is not complete (that is, one or more states do not have successors for certain alphabet symbols), then it is made complete by adding an accepting sink state. This sink state is not actually a part of the upper part, and it is not further processed during the rest of the construction. However, its presence is important in case the upper part is not complete. 

The result of this first stage of the construction is a deterministic and complete automaton that does not contain any accepting states (except a possible sink state, but which, as mentioned, does not really belong to the upper part).


\subsubsection{Example}

We will illustrate the application of the Fribourg construction with the example automaton in Figure~\ref{example_automaton}. This automaton has only  one single alphabet symbol $a$. This choice was made to keep the example simple, because an alphabet size of, say 2, would double the number of steps and the number of transitions in the output-automaton. However, the procedure for automata with larger alphabets is exactly the same, just repeat the step of creating a successor state for the current state for each alphabet symbol.

\begin{figure}
\centering
\Automaton
\caption{Example automaton.}
\label{example_automaton}
\end{figure}

The example automaton in Figure~\ref{example_automaton} does not accept any word, because it is impossible for any run to visit the only accepting state $q_1$ infinitely many times. The automaton $A$ is thus empty. Consequently, the complement of $A$ is universal, that is, it accepts every possible word\footnote{The only possible \om-word with the alphabet $\Sigma = \{a\}$ is $a^\omega$, that is an infinite sequence of $a$'s.}.

Figure~\ref{steps_upper} shows the complete steps for creating the upper part from the example automaton in Figure~\ref{example_automaton}. In Figure~\ref{steps_upper} (a), we start with a state containing only the component \qq0, because \q0 is the initial state of $A$.

\begin{figure}[htb]
\centering
  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \UpperPartA
  \caption{}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \UpperPartB
  \caption{}
  \end{subfigure}

  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \UpperPartC
  \caption{}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \UpperPartD
  \caption{}
  \end{subfigure}
\caption{Steps for creating the upper part of the complement from the example input-automaton in Figure~\ref{example_automaton}.}
\label{steps_upper}
\end{figure}

In Figure~\ref{steps_upper} (b), we determine the $a$-successor of the state $(\qm0)$. As explained, this works by looking at the state as a slice of a reduced split tree, and then creating the succeeding slice. For the case of $(\qm0)$, this gives the following two slices:

\SlicesOne

From the state \q0 in the example automaton $A$, we can reach states \q0, \q1, and \q2 with the symbol $a$. Since \q1 is accepting, it is separated from the other states and put as a separate child to the right of the other child in the new slice. Transforming this new slice back to a state yields $(\qqm02, \qm1)$, which is the $a$-successor of $(\qm0)$. The component \qq1 is furthermore an accepting component, however, this does not matter in the construction of the upper part. Since there is only the single alphabet symbol $a$, we have already created all the successors of $(\qm0)$. If there would be more alphabet symbols, we would have to repeat the same procedure for each symbol.

In Figure~\ref{steps_upper} (c), we create the $a$-successor of the previously created $(\qqm02, \qm1)$. Applying the same procedure as before, we get the following two slices:

\SlicesTwo

Since we use right-to-left reduced split trees, we have to create the new slice from right to left, that is, first determining the children of vertex \q1, and then of \qqq02. From \q1 we can only reach \q2 on symbol $a$, thus the only child of \qq1 is \qq2. From the states in \qqq02, we can reach \q0, \q1, and \q2 on symbol $a$. However, \q1 already appears in the new slice, so it drops out. From the remaining states \q0 and \q1, \q1 is accepting, so it becomes a separate right-child, whereas \q0 becomes the left-child. Translating this slice to a state yields $(\qm0, \qm1, \qm2)$, which is the $a$-successor of $(\qqm02, \qm1)$.

In Figure~\ref{steps_upper} (d), we determine in turn the $a$-successor of $(\qm0, \qm1, \qm2)$. Applying again the slice-procedure, we get the following:

\SlicesThree

Again, we process the vertices of the upper slice from right to left. The only $a$-successor of \q2 in automaton $A$ is \q2, thus \qq2 is the only child of the vertex \qq2 in the upper slice. The state \q1 has \q2 as its $a$-successor. However, \q2 already appears in the new slice, and thus it drops out. Since \q1 has no remaining $a$-successors, the vertex \qq1 in the upper slice remains childless\footnote{In the terminology that we will use starting from the next section, we say that the runs going through this \q1 ``disappear''.}. Finally, the $a$-successors of \q0 are \q0, \q1, and \q2, however, as before, \q2 drops out because it already appears to the right, and \q0 and \q1 are separated because \q1 is accepting. Translating the new slice back to a state results in $(\qm0, \qm1, \qm2)$, whichi s identical to the current state. Thus, instead of adding a new state to the automaton, we just add an $a$-loop to $(\qm0, \qm1, \qm2)$.

At this stage, all the existing states have successors for all the alphabet symbols, and thus the construction of the upper part is completed. The next step is to attach the lower part to the upper part in order to form the final complement automaton.



\subsection{Lower Part}
The construction of the lower part takes the states of the previously constructed upper part as input. This means that these states are taken as the initial ``states to be processed''. Thus, the states of the upper part will get additional successors in the lower part, which makes the states of the upper part non-deterministic\footnote{Two points about this non-determinism are interesting. First, the states of the upper part are the only non-deterministic states, all the other states are deterministic. Second, the degree of non-determinism of these states is at most 2, and thus the degree of non-determinism of the entire complement automaton is at most 2.}. The states of the lower part, in turn, are deterministic, and do not have transitions back to the upper part. This means that once a run switches from the upper to the lower part, it stays there infinitely (or dies there). 

The construction of the lower part proceeds principially in the same way as the construction of the upper part. However, it includes some additional ``structure'' in the form of a decoration of the components. In particular, every component of a lower-part state is assigned a colour. This colour is determined at creation time of the containing state, and is never changed\footnote{The colour of a component may be changed with the optimisations described in Section~\ref{3_optimisations}.}. These colours are distinguising features for the containing states. This means that if two states contain the same components in the same order, but the components have different colours, then the two states are different. Clearly, this makes the number of possible states of the lower part much larger than the number of possible states of the upper part.

We denote these three colours for the components of the lower part by 0, 1 and 2. In order to determine the accepting set at the end of the construction, it is necessary to ditinguish the states from the upper part from the states of the lower part. This problem is solved by previously assigning the special colour $-1$ to all components of upper part-states.

The assignment of a colour to a component of a lower-part state depends on three things:
\begin{enumerate}
\item Whether the component is accepting or non-accepting
\item The colour of the predecessor component
\item Whether the state containing the predecessor component contains any 2-coloured components
\end{enumerate}

How much to describe the concept of predecessor component, as it is already described in Section~\ref{3_basics}?

The rules for assigning one of the colours 0, 1, and 2 to a component $c$ are shown in Figure~\ref{colour_rules}. There are two different sets of rules for the cases that the state containing the predecessor component \textit{does} (Figure~\ref{colour_rules} (b)), or \textit{does not} ((Figure~\ref{colour_rules} (a)) contain components with colour 2. In each of these cases, the two remaining criteria, whether $c$ is accepting or non-accepting, and the colour of the predecessor component $c_{pred}$, determine a single colour that must be assigned to component $c$ (bold in Figure~\ref{colour_rules}). 

\begin{figure}[htb]
\centering
  \begin{subtable}[t]{\textwidth}
  \renewcommand{\arraystretch}{1.3}
  \centering
  \begin{tabular}{|C{3cm}|C{3cm}|C{3cm}|}
    \hline
    Colour of $c_{pred}$ & $c$ is non-accepting & $c$ is accepting \\
    \hline
    $-1$ & \textbf{0} & \textbf{2} \\
    0 & \textbf{0} & \textbf{2} \\
    1 & \textbf{2} & \textbf{2} \\
    \hline
  \end{tabular}
  \caption{Case A: the predecessor state has \textit{no} 2-coloured components}
  \end{subtable}
  \vskip0.5cm

  \begin{subtable}[t]{\textwidth}
  \renewcommand{\arraystretch}{1.3}
  \centering
  \begin{tabular}{|C{3cm}|C{3cm}|C{3cm}|}
    \hline
    Colour of $c_{pred}$ & $c$ is non-accepting & $c$ is accepting \\
    \hline
    0 & \textbf{0} & \textbf{1} \\
    1 & \textbf{1} & \textbf{1} \\
    2 & \textbf{2} & \textbf{2} \\
    \hline
  \end{tabular}
  \caption{Case B: the predecessor state \textit{has} 2-coloured components}
  \end{subtable}
\caption{Rules for determining the colour of a component $c$, based on (1) the colour of the predecessor component $c_{pred}$, and (2) whether $c$ is an accepting or non-accepting component. There are two set of rules that are shown in the two subfigures: (a) the predecessor state does not have any components with colour 2, and (b) the predecessor state does have one or more components with colour 2.}
\label{colour_rules}
\end{figure}

In the first case, that the predecessor state contains no 2-coloured components, the possible colours of the predecessor components are $-1$, 0, and 1. Naturally, the predecessor component cannot be 2-coloured, but on the other hand, it might have colour $-1$, if the predecessor state is a state of the upper part. For the other case, that the predecessor state contains 2-coloured components, the possible colours for the predecessor component naturally include colour 2, but do not include colour $-1$, because a state containing 2-coloured components cannot be a state of the upper part.

The purpose of the colours is to signalise the presence or absence of certain runs of the input automaton on a specific word. Note that the complement of a non-deterministic automaton must accept a word if and only if \textit{all} the runs of the input automaton on this words are rejecting. If there is a single run of the input automaton that accepts the word, then the complement automaton must not accept the word. Thus, we need a way to be sure that there are \textit{no} accepting runs of the input automaton on a specific word, and then we can accept this word with the complement automaton. 

\begin{description}
\item[Colour 2]
Is used to signalise the presence of ``dangerous'' runs, that is, runs that have the potential to becom accepting. If a component has colour 2, it means that there are input-runs that made a ``right-turn'', in terms of slices of reduced split trees, that is, visited an accepting state (see rules in Figure~\ref{colour_rules} (a) line 1 and 2). Note that all the successor components of a 2-coloured component are also 2-coloured, no matter if they are accepting or non-accepting (Figure~\ref{colour_rules} (b) line 3). A ``string'' of 2-coloured components can only be cut if a 2-coloured component has no successor components (no children in terms of reduced split trees). In this case we say that the 2-coloured component ``disappears''.

\item[Colour 1]
Means basically the same as colour 2, namely that there are ``dangerous'' runs. The reason that colour 1 exists is a caveat that could arise if we would assign colour 2 to \textit{every} component that just made a right-turn. In this case, it could happen that we miss the disappearance of 2-coloured components, and thus keep the containing output-state non-accepting instead of accepting. For this reason, the trick with colour 1 works as follows. If the predecessor state already contains 2-coloured components, then every component of the current state that deserves to be 2-coloured gets colour 1 instead of colour 2. This can be seen in Figure~\ref{colour_rules} (b) line 1 and 2. These are actually ``dangerous'' components kept ``on hold'', becaus then trick goes on as follows. As soon as all the 2-coloured components of a state disappear, the successors of all the 1-coloured components get 2-coloured. This can be seen in Figure~\ref{colour_rules} (a) line 3. At this point, these ``dangerous'' components ``on hold'' get the real ``dangerous'' components.

\item[Colour 0]
Means the absence of ``dangerous'' runs. This is because the corresponding input-run did not make any right-turns, that is, they went only through non-accepting states. These runs are ``safe'' in the sense that so far they bear no risk of becoming accepting runs.
\end{description}

Wrapping up, for constructing the lower part of the output automaton, one just has to apply the same successor creation procedure as for the upper part, with the addition of assigning colours to the new states' components according to the rules in Figure~\ref{colour_rules}. In the end, when every state has been processed and the procedure ends, the only thing that is missing is to determine the accepting states of the resulting automaton. The rule is that every state of the lower part that does \textit{not} contain any 2-coloured components is an accepting states. That means that every state of the automaton that contains exclusively 0-coloured and/or 1-coloured components is an accepting state.

In the following, we demonstrate the application of the lower-part construction by an example.


\subsubsection{Example}
We continue the complementation of the example automaton in Figure~\ref{example_automaton} with the construction of the lower part. Therefore, we start where we left off the example in the last section, namely with the upper part. For this example, we will use the following notation for specifying the colour of a component $\{q\}$:
\begin{itemize}
\item $\cl^{\{q\}}$: colour $-1$
\item $\cl0{\{q\}}$: colour 0 \vphantom{$\cl2{\{q\}}$}  % Strut
\item $\cl1{\{q\}}$: colour 1 \vphantom{$\cl2{\{q\}}$}  % Strut
\item $\cl2{\{q\}}$: colour 2
\end{itemize}

Figure~\ref{steps_lower} shows some of the steps of the construction of the lower part. In Figure~\ref{steps_lower} (a), we start with the upper part that we previously constructed in the last section. The only difference is that we assigned colour $-1$ to all of the components of the upper part.

\begin{figure}[htb]
\centering
  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \ComplementA
  \caption{}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \ComplementB
  \caption{}
  \end{subfigure}

  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \ComplementC
  \caption{}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.49\textwidth}
  \centering
  \ComplementD
  \caption{}
  \end{subfigure}
\caption{Selected steps of the construction of the lower part, starting with the upper part }
\label{steps_lower}
\end{figure}

In Figure~\ref{steps_lower} (b), we created the $a$-successors of the three states of the upper part. The structure of these new states, apart from the colours, is determined by the same method that we used for the upper part. The only difference in the construction of the lower part is that each component is assigned a colour. For both new states, the predecessor states do not contain any 2-coloured components, thus we only need to consider the colour rules in Figure~\ref{colour_rules} (a). Regarding the colour of the predecessor components, they all have colour $-1$, thus we have to use the rule in Figure~\ref{colour_rules} (a) line 1 for all the new components. In this way, the components \qqq02, \qq0, and \qq2 are assigned colour 0, because they are non-accepting, and component \qq1 gets colour 2, because it is accepting.

Note how we have to keep track for each component of the lower part whether it is accepting or non-accepting, and which is its predecessor component in the predecessor state. 

In Figure~\ref{steps_lower} (c), we added the $a$-successor to the state $(\qqm02, \cl2{\qm1})$. Disregarding the colours, this state has the form $(\qm0, \qm1, \qm2)$. Its predecessor state $(\qqm02, \cl2{\qm1})$ contains a 2-coloured component, thus we have to use the colour rules in Figure~\ref{colour_rules} (b). Now we need to know which are the predecessor components of the components in $(\qm0, \qm1, \qm2)$. This information is contained in the two slices of the reduced split tree that were used to determine the structure of the new state. For the case of our two states, the successor relation of their components is as follows:

\PredCompsOne

The predecessor component of \qq0 is \qqq02, which has colour 0. Thus, we have to use the rule in Figure~\ref{colour_rules} (b) line 1, and \qq0 gets the colour 0, because it is non-accepting. The predecessor component of \qq1 is also \qqq02, and we have to use the same rule. However, since \qq1 is accepting, it gets colour 1. Note how the use of colour 1 here prevents the introduction of a further 2-coloured component before an already existing 2-coloured component has disappeared. The predecesor component of \qq2 is the 2-coloured $\cl2{\qm1}$, and thus, according to the rule in Figure~\ref{colour_rules} (b) line 3, \qq2 also gets colour 2.

Next, still in Figure~\ref{steps_lower} (c), we create in turn the successor state of $(\qm0, \cl1{\qm1}, \cl2{\qm2})$. The structure of the components stays the same for the successor. The succesor relation of the two states is as follows:

\PredCompsTwo

The result is that \qq0 gets colour 0, \qq1 gets colour 1, and \qq2 gets colour 2. Thus, the successor state is identical to the current state, and we add loop.

Figure~\ref{steps_lower} (d) includes the remaining for arriving at the final complement automaton. First, we created the $a$-successor of the state $(\qm0, \cl2{\qm1}, \qm2)$. The complement successor relation of this state with its successor is as follows:

\PredCompsThree

According to the rules in Figure~\ref{colour_rules} (b), component \qq0 gets colour 0, \qq1 gets colour 1, and \qq2 gets colour 0. This results in a new state, since the colours are different from the ones in the current state. Interesting here is that we have the case that a 2-coloured component ``disappears''. This is because the component $\cl2{\qm1}$ has no successor component in the successor state. For the $a$-successor of the new state $(\qm0, \cl1{\qm1}, \qm2)$, this means in turn that we have to use the rules in Figure~\ref{colour_rules} (a), what results in the already existing state $(\qm0, \cl2{\qm1}, \qm2)$.

At this point, all the states in the automaton have been processed, and the construction is therefore completed. The only thing that remains to be done is to determine the accepting states of the automaton. The rule is that each state of the lower part that does not contain any 2-coloured component is an accepting state. In our automaton this applies only to the state $(\qm0, \cl1{\qm1}, \qm2)$, which is thus the only accepting state of the automaton.

It can be easily seen that the automaton in Figure~\ref{steps_lower} accepts the word $a^\omega$, which is not accepted by the input automaton in Figure~\ref{example_automaton}. Thus, the result of our construction is a correct complement of the input automaton.

A loose upper bound for the worst-case state complexity of the entire construction (including the construction of both, the upper and the lower part) has been calculated to be in $O((1.59n)^n)$, where $n$ is the number of states of the input automaton~\cite{2014_joel_ulrich}. This result is subject to refinement in ongoing research by the authors of the Fribourg construction. As mentioned, this publication (\cite{2014_joel_ulrich}) also contains a formal desciption and a proof of correctness of the construction.


\section{Optimisations}
\label{3_optimisations}
There are several optimisations to the basic Fribourg construction, which all have the goal to reduce the size of the output automaton. These optimisations are like ``add-ons'' and can  be added to the basic construction and combined in different ways.

In this section, we describe three of these optimisations. For easier reference, we define an abbreviation for each optimisation: R2C, M1, and M2. These optimisations will also be subject to the empirical performance investigation of the Fribourg construction, starting from the next chapter, and there we will use the same abbreviations.

\subsection{R2C: Remove States with Rightmost 2-Coloured Components}
The R2C optimisation can be summarised as follows:

\begin{quote}
If the input automaton is complete, then states of the lower part whose rightmost component has colour 2 can be omitted.
\end{quote}

This means that if during the construction of the lower part we determine a state that has a 2-coloured rightmost component, then we do not need to add this state to the automaton. This consequently also omits all the potential successors of this state from the automaton.

The reason for this is the following fact. If the input automaton is complete, then the rightmost component of an output-state \textit{always} has at least one successor component (because of the completeness of the input automaton). However, this applies only to the rightmost component, as the successors of the other components might be omitted, due to the right-to-left precedence in right-to-left reduced split trees.

If the colour of the rightmost component is 2, then the successor component inherits this colour 2 (Figure~\ref{colour_rules} (b) line 3). This means inductively that all the successors of a state with a 2-coloured rightmost component will have a 2-coloured rightmost component. Or in other words, there is a 2-coloured component that will never disappear. Since states containing a 2-coloured component are non-accepting, these states form a cycle without a single accepting state, and this cycle can be removed without changing the language of the automaton.

Note, however, that the omission of these states can only be done if the input automaton is complete. 


\subsection{M1: Merge Components}
The M1 optimisation allows the merging of adjacent components depending on their colour. With the merging of adjacent components, we mean the replacement of these components with their union (if regarding components as sets). The three merging rules are as follows.

\begin{enumerate}
\item Two adjacent 1-coloured components can be merged to a single 1-coloured component
\item Two adjacent 2-coloured components can be merged to a single 2-coloured component
\item A 2-coloured component adjacent to a 1-coloured component (in this order from left to right) can be merged to a single 2-coloured component
\end{enumerate}

These mergings can be done recursively. This means that the result of a merging can again be subject to further merging, until nothing more can be merged. For example, the state $(\qm0, \cl2{\qm1}, \cl2{\qm2}, \cl1{\qm3}, \cl1{\qm4}, \cl2{\qm5})$ can be transformed to $(\qm0, \cl2{\{q_1, q_2, q_3, q_4, q_5\}}$, by the recursively applying the above three merging rules.

Consequent applying of these mergings reduces the maximal number of states in the output automaton. An upper bound on the number of states in the lower part of the automaton has been calculated to be in $O((1.195n)^n)$, where $n$ is the number of states of the input automaton~\cite{2014_joel_ulrich}. This is considerably lower than the $O((1.59n)^n)$ worst-case state growth of the Fribourg construction without the M1 optimisation. A formal description and a proof of correctness of the M1 optimisation can be found in~\cite{2014_joel_ulrich} (Section 4.E).


\subsection{M2:  }
The M2 optimisation is the most involved of the three optimisations. Furthermore, it can only be applied together with the M1 optimisation. The main point of the M2 optimisation can be summarised as follows:

\begin{quote}
Every state of the lower part contains \textit{at most} one 2-coloured component.
\end{quote}

The purpose of this restriction is to further reduce the maximal number of states the construction can generate (that is, to reduce the worst-case state complexity of the construction).

\begin{itemize}
\item When determining the colours of the components of a new state, the components must be processed from right to left
\item The first component that according to the rules in Figure~\ref{colour_rules} deserves colour 2 gets colour 2 as usual
  \begin{itemize}
  \item If this component has a sibling\footnote{With sibling we mean having the same predecessor component.} to its left, then this sibling gets colour 2 as well
  \end{itemize}
\item From the point on where colour 2 has been assigned to a component (and possibly its sibling), all the further components that according to Figure~\ref{colour_rules} deserve colour 2 get colour 1 instead of colour 2
\end{itemize}

This leaves the new state in a situation where at most two components have colour 2, namely the first one that deserves it from the right, and its possible sibling. In the case that there was a sibling, the application of the M1 optimisation (which is necessary for the application of the M2 optimisation) merges these two components to a single 2-coloured component. This makes the state in any case having at most one 2-coloured component.

This modification of the construction requires further care to be taken when the only 2-coloured component of a state ``disappears'', that is, has no successor components in the state under construction. In this case, one of the 1-coloured components of this state is made accepting. In more detail, the points to consider are as follows.

\begin{itemize}
\item Disappearance of a 2-coloured component: uf the predecessor of a new state has a 2-coloured component, and if after the assignment of colours to the components of this new state, as described above, the new state has no 2-coloured component, then we say that the 2-coloured component of the predecesor state disappeared.
\item When the disappearance of a 2-coloured component is detected, and if the state under construction contains at least one 1-coloured component, then the following is done:
  \begin{itemize}
  \item The position where the successor component of the disappeared component \textit{would} be is determined
  \item Select the first 1-coloured component that is to the left of the first a 0-coloured component that is to the left of this position
    \begin{itemize}
    \item If the search arrives at the leftmost component of the state, then continue it starting from the rightmost component
    \item If there is exactly one 1-coloured component in the state, then directly select this component
    \end{itemize}
  \item Change the colour of the selected component from 1 to 2
  \item Mark the state with a special mark (for example a $*$)
    \begin{itemize}
    \item This mark distinguished states. That is, if two states have the same components with the same colours, but one has a mark and the other not, then they are two different states.
    \end{itemize}
  \end{itemize}
\end{itemize}

The result of this procedure is that the state has a single 2-coloured component again. However, as mentioned, this state must be accepting, even though it contains a 2-coloured component. It is the purpose of the mark to distinguish this state from other states with a 2-coloured component. The last thing we have to do is to change the acceptance condition to include all states of the lower part containing no 2-coloured components, plus all states having a mark.


\begin{figure}
\centering
\ComplementWithMTwo
\caption{Result of applying the M2 optimisation to the complementation of the example automaton from Figure~\ref{example_automaton}.}
\label{complement_with_m2}
\end{figure}

In this case, the difference is the marked state $(\qm0, \cl2{\qm1}, \qm2)*$. It exists, because the 2-coloured component $\cl2{\qm1}$ of the predecessor state disappears. According to the colour rules, the $\cl1{\qm1}$ in the new state then gets colour 1. This is where the construction without the M2 optimisation would left off. With the M2 optimisation, however, we have to select one of the 1-coloured components of the new state and change its colour to colour 2. There is only one 1-coloured component in the state, $\cl1{\qm1}$, and so we change its colour from~1 to~2. We also mark this state with a star. The successor of this marked state happens to be identical with itself (because the component $\cl2{\qm1}$ again disappears), so we add a loop. In the end, the marked state is made accepting.

In~\cite{2014_joel_ulrich} (Section 4.H) a very loose upper bound on the number of states of the lower part of $O((0.86n)^n)$ is proposed. This is a significant reduction from the upper bound of $O((1.195n)^n)$ that s achieved with the M1 optimisation. Furthermore, concrete calculations on the M2 optimisation suggest that the real upper bound might be as low as $O((0.76n)^n)$. This coincides with the established lower bound for B체chi complementation by Yan~\cite{DBLP:journals/corr/abs-0802-1226} and would make the construction optimal in the sense of worst-case state complexity. The actual complexity of the M2 optimisation is subject to further research by the authors of the Fribourg construction.



\cite{2014_joel_ulrich} Section 4.H



% The Fribourg construction draws from several ideas: the subset construction, run analysis based on reduced split trees, and Kurshan's construction~\cite{Kurshan198759} for complementing DBW. Following the classification we used in Section~\ref{review}, it is a slice-based construction. Some of its formalisations are similar to the slice-based construction by Vardi and Wilke~\cite{vardi2007automata}, however, the Fribourg construction has been developed independently. Furthermore, as we will see in Chapter~\ref{results}, the empirical performance of Vardi and Wilke's construction and the Fribourg construction differ considerably, in favour of the latter.

% Basically, the Fribourg construction proceeds in two stages. First it constructs the so-called upper part of the complement automaton, and then adds to it its so-called lower part. These terms stem from the fact that it is often convenient to draw the lower part below the previously drawn upper part. The partitioning in these two parts is inspired by Kurshan's complementation construction for DBW. The upper part of the Fribourg construction contains no accepting states and is intended to model the finite ``start phase'' of a run. At every state of the upper part, a run has the non-deterministic choice to either stay in the upper part or to move to the lower part. Once in the lower part, a run must stay there forever (or until it ends if it is discontinued). That is, the lower part models the infinite ``after-start phase'' of a run. The lower part now includes accepting states in a sophisticated way so that at least one run on word $w$ will be accepted if and only if all the runs of the input NBW on $w$ are rejected.

% As it may be apparent from this short summary, the construction of the lower part is much more involved than the construction of the upper part.

% \begin{figure}
% \begin{center}
% \Automaton
% \caption{Example automaton $A$}
% \label{example_automaton}
% \end{center}
% \end{figure} 


% \section{First Stage: Constructing the Upper Part}
% The first stage of the subset-tuple construction takes as input an NBW $A$ and outputs a deterministic automaton \Bp. This \Bp is the upper part of the final complement automaton $B$ of $A$. The construction of \Bp can be seen as a modified subset construction. The difference to the normal subset construction lies in the inner structure of the constructed states. While in the subset construction a state consists of a subset of the states of the input automaton, a \Bp-state in the subset-tuple construction consists of a \emph{tuple of subsets} of $A$-states. The subsets in a tuple are pairwise disjoint, that is, every $A$-state occurs at most once in a \Bp-state. The $A$-states occurring in a \Bp-state are the same that would result from the classic subset construction. As an example, if applying the subset construction to a state \qq0 results in the state \qqqq012, the subset-tuple construction might yield the state $(\qqm02,\qm1)$ instead.

% The structure of \Bp-states is determined by levels of corresponding reduced split trees. Vardi, K채hler, and Wilke refer to these levels as \emph{slices} in their constructions~\cite{vardi2007automata,2008_kaehler}. Hence the name slice-based approach. In the following, we will use the terms levels and slices interchangebly. A slice-based construction can work with either left-to-right or right-to-left reduced split trees. Vardi, K채hler, and Wilke use the left-to-right version in their above cited publications. In this thesis, in contrast, we will use right-to-left reduced split trees, which were also used from the beginning by the authors of the subset-tuple construction.

% Figure~\ref{levels_to_states} shows how levels of a right-to-left reduced split tree map to states of the subset-tuple construction. In essence, each node of a level is represented as a set in the state, and the order of the nodes determines the order of the sets in the tuple. [INFORMATION ABOUT ACC AND NON-ACC IS NEEDED IN THE LOWER PART BUT IMPLICIT IN THE STATES OF A]. To determine the successor of a state, say $(\qqm02,\qm1)$, one can regard this state as level of a reduced split tree, determine the next level and map this new level to a state. In the example of Figure~\ref{levels_to_states}, the successor of $(\qqm02,\qm1)$ is determined in this way to $(\qm0,\qm1,\qm2)$.

 

% Apart from this special way of determining successor states, the construction of \Bp proceeds similarly as the subset construction. One small further difference is that if at the end of determining a successor for every state in \Bp, the automaton is not complete, it must be made complete with an \emph{accepting} sink state. The steps for constructing \Bp from $A$ can be summarised as follows.

% \begin{itemize}
% \item Start with the state $(\qm0)$ if \q0 is the initial state of $A$
% \item Determine for each state in \Bp a successor for every input symbol
% \item It at the end \Bp is not complete, make it complete with an accepting sink state
% \end{itemize}

% For the example automaton $A$ in Figure~\ref{example_automaton}, we would start with $(\qm0)$, determine $(\qqm02,\qm1)$ as its $a$-successor, whose $a$-successor in turn we determine a $(\qm0,\qm1,\qm2)$. The $a$-successor of $(\qm0,\qm1,\qm2)$ is $(\qm0,\qm1,\qm2)$ again what results in a loop. Figure~\ref{upper_part} shows the final upper part \Bp of $A$.

% \begin{figure}
% \begin{center}
% \UpperPart
% \caption{Upper part \Bp of example automaton $A$.}
% \label{upper_part}
% \end{center}
% \end{figure} 


% The construction of the upper part takes as input a NBW $A$ and outputs a deterministic automaton $B^\prime$ that will be the upper part of the final complement automaton $B$. The construction of $B^\prime$ is in its approach similar to the subset construction. One starts with a $B^\prime$-state representing the initial state of $A$ and then recursively determines and adds for each $B^\prime$-state one successor state per input symbol. The difference to the subset construction lies in the inner structure of the $B^\prime$-states. In the subset construction this would simply be a single set of $A$-states. In the subset-tuple construction, however, a $B^\prime$-state is a tuple of sets of $A$-states. A tuple is an ordered list, so differently phrased, a $B^\prime$-state consists of one or more sets of $A$-states where the order of these sets matters. As we will see, the $A$-states present in a $B^\prime$-state are the same that would result from the subset construction. But while in the subset construction all these states are thrown together in one set, in the subset-tuple construction they are split up in multiple sets where additionally the order of these sets is important. The subset-tuple construction can thus be seen as a modified subset construction that includes additional structure.

% The structure of $B^\prime$-states is defined by ``level-clippings'' of reduced split trees, as we explain in a moment. But, talking about reduced split trees, we have to make a decision first. In Section~\ref{r_split_trees} we mentioned that reduced split trees come in equivalent left-to-right and right-to-left versions. The construction has to adopt one of these variants and stick to it. In this thesis we use the right-to-left version. The final complement automata look the same with either version except that the order of the tuples is reversed. Note that the optimisations described in Section~\ref{optimisations} is also based on this ordering and would need to be rephrased for the left-to-right version.

% \begin{figure}
% \begin{center}
% \Slices
% \end{center}
% \caption{From levels of a reduced split tree to the slices of the subset-tuple construction.}
% \label{levels_to_states}
% \end{figure} 

% A new $B^\prime$-state $q$, successor on symbol $a$ of an already existing $B^\prime$-state $p$, now is created in the following way. The predecessor $p$ is regarded as a level of a reduced split tree by looking at its sets as the nodes on this level. Then, the next level for the given symbol $a$ is constructed as described in Section~\ref{r_split_tree}. This new level then directly defines $q$ by taking the nodes as the sets of $q$'s tuple and keeping their order. Figure~\ref{tree_to_slices} illustrates this with the example automaton $A$ that we already used before. If a state with a simlar tuple to the just created $q$ already exists in $B^\prime$, then just a transition from $p$ to this state is added (hence the loop in the third state of Figure~\ref{tree_to_slices}). The construction starts with a $B^\prime$-state containing only $A$'s initial state and ends when all states of $B^\prime$ have been processed for all input symbols. In Figure~\ref{tree_to_slices}, the construction is complete, thus the automaton shown at the right is the upper part of the complement of $A$.

% If all the $A$-states of a $B^\prime$-state $p$ have no successors on an input symbol $a$, then $p$ will have no $a$-successor in $B^\prime$. This results in the upper part $B^\prime$ being incomplete at the end of the construction. In this case, it has to be made complete by adding a sink state. Furthermore, this sink state has to be accepting.

% States of the subset-tuple construction are thus levels of reduced split trees. In the constructions of Varid and Wilke~\cite{vardi2007automata}, and K채hler and Wilke~\cite{2008_kaehler} states are called \emph{slices} of reduced split trees, hence the name slice-based approach.

% \begin{figure}
% \begin{center}
% \UpperPart
% \end{center}
% \caption{Upper part of complement of $A$.}
% \label{upper_part}
% \end{figure} 


% \section{Second Stage: Adding the Lower Part}
% The second stage of the subset-tuple construction adds the lower part to the upper part \Bp. The two parts together form the final complement automaton $B$. The lower part is constructed by again applying a modified subset construction to the states of the upper part \Bp. This modified subset construction is an extension of the construction for the upper part. The addition is that each set gets decorated with a colour. These colours later determine which states of the lower part are accepting states.

% We divide our discussion of the lower part in two sections. In the following one (\ref{lower_part:steps}), we explain the ``mechanical'' construction of the lower part, the steps that have to be done to arrive at the final complement automaton $B$. In the next section (\ref{lower_part:intuition}) we give the idea and intuition behind the construction and explain why it works.

% \subsection{Construction}
% \label{lower_part:steps}
% As mentioned, every set of the states of the lower part gets a colour. There are three colours and we call them 0, 1, and 2. In the end we have to be able to disinguish the states of the upper part from the states of the lower part. This can be achieved by preliminarily assigning the special colour -1 to every set of the states of the upper part. After that the extended modified subset construction is applied, taking the states of the upper part (except a possible sink state) as the pre-existing states.

% At first, the extended modified subset construction determines the successor tuple (without the colours) of an existing state in the same way as the construction of the upper part. We will refer to the state being created as $p$ and to the existing state as $p_{pred}$. Then, one of the colours 0, 1, or 2 is determined for each set $s$ of $p$. We denote the colour of $s$ as $c(s)$. The choice of $c(s)$ depends on three factors.
% \begin{itemize}
% \item Whether $p_{pred}$ has a set with colour 2 or not
% \item The colour of the predecessor set $s_{pred}$ of $s$
% \item Whether $s$ is an accepting or non-accepting set
% \end{itemize}
% The predecessor set $s_{pred}$ is the set of $p_{pred}$ that in the corresponding reduced split tree is the parent node of the node corresponding to $s$. Figure~\ref{colours} shows the values of $c(s)$ for all possible situations as two matrices. There is one matrix for the two cases of factor 1 above ($p_{pred}$ has colour 2 or not) and the other two factors are laid out along the rows and columns of either matrix. Note that $c(s_{pred}) = -1$ is only present in the upper matrix, because in this case $p_{pred}$ is a state of the upper part and cannot contain colour 2.



% We will use the following notation to denote the colour of $s$: $\cl^{s}$ if $c(s) = -1$, $s$ if $c(s) = 0$, $\cl1{s}$ if $c(s) = 1$, and $\cl2{s}$ if $c(s) = 2$. Let us look now at a concrete example of this construction. We will add the lower part to the upper part \Bp in Figure~\ref{upper_part}, and thereby complete the complementation of the example automaton $A$ in Figure~\ref{example_automaton}.

% First of all, we assign colour $-1$ all the sets of the states of \Bp. We might then start processing the state $(\cl^{\qm0})$, let us call it $p_{pred}$. The resulting successor tuple, without the colours, of $p_{pred}$ is, as in the upper part, $(\qqm02,\qm1)$. We now have to determine the colours of the sets \qqq02 and \qq1. Since $p_{pred}$ does not contain any 2-coloured sets, we need only to consult the upper matrix in Figure~\ref{colours}. For \qq1, the predecessor set is $\cl^{\qm1}$ with colour $-1$. Furthermore \qq1 is accepting. So, the colour of \qq1 is 2, because we end up in the first-row, second-column cell of the upper matrix ($M_1(1,2)$). The other set, \qqq02, in turn is non-accepting, so its colour is 0 ($M_1(1,1)$). The successor state of $(\cl^{\qm0})$ is thus $(\qqm02,\cl2{\qm1})$.

% We can then continue the construction right with this new state $(\qqm02,\cl2{\qm1})$, and call it $p_{pred}$ in turn. The successing tuple without the colours of $p_{pred}$ is $(\qm0,\qm1,\qm2)$. Since $p_{pred}$ contains a set with colour 2, we have to consult the lower matrix of Figure~\ref{colours} to determine the colours of \qq0, \qq1, and \qq2. For \qq2, we end up with colour 2 ($M_2(3,1)$), because its predecessor set, which is $\cl2{\qm1}$, has colour 2. \qq1 gets colour 1 as it is accepting and its predecessor set, \qqq02, has colour 0 ($M_2(1,2)$). \qq0, which has the same predecessor set, gets colour 0, because it is non-accepting ($M_2(1,1)$). The successor state of $(\qqm02,\cl2{\qm1})$ is thus $(\qm0,\cl1{\qm1},\cl2{\qm2})$.

% \begin{figure}[htb]
% \centering
%   \begin{subfigure}[t]{0.49\textwidth}
%   \centering
%   \ComplementA
%   \caption{Upper part}
%   \end{subfigure}
%   \hfill
%   \begin{subfigure}[t]{0.49\textwidth}
%   \centering
%   \ComplementB
%   \caption{Complete}
%   \end{subfigure}

%   \begin{subfigure}[t]{0.49\textwidth}
%   \centering
%   \ComplementC
%   \caption{Upper part}
%   \end{subfigure}
%   \hfill
%   \begin{subfigure}[t]{0.49\textwidth}
%   \centering
%   \ComplementD
%   \caption{Complete}
%   \end{subfigure}
% \caption{The final complement automaton $B$.}
% \label{complement}
% \end{figure}

% \begin{figure}[htb]
% \centering
% \Complement
% \end{figure}

% The construction continues in this way until every state has been processed. The resulting automaton is shown in Figure~\ref{complement}. The last thing that has to be done is to make every state of the lower part that does not contain colour 2 accepting. In our example, this is only one state. The NBW $B$ in Figure~\ref{complement} is the complement of the NBW $A$ in Figure~\ref{example_automaton}, such that $L(B) = \cl1{L(A)}$. This can be easily verified, since $A$ is empty and $B$ is universal (with regard to the single \om-word $a^\omega$).

% \subsection{Meaning and Function of the Colours}


% \section{Intuition for Correctness}
% The general relation between a non-deterministic automaton $A$ and its complement $B$ is that a word $w$ is accepted by $B$, if and only if all the runs of $A$ on $w$ are rejecting. Of course for the subset-tuple construction, as we have just described it above, this is also true. A formal proof can be found in~\cite{2014_joel_ulrich}. In this section, in contrast, we try to give an intuitive way to understand this correctness. One one hand, there is the question, if there is an accepting run of $B$ on $w$, how can we conclude that all the runs of $A$ on $w$ are rejected?

% \begin{itemize}
% \item If there is an accepting run of $B$ on $w$, how can we conclude that all the runs of $A$ on $w$ are rejected?
% \item If all the runs of $A$ on $w$ are rejected, how can we conclude that there must be an accepting run of $B$ on $w$?
% \end{itemize}


% Since this condition is on \emph{all} runs of $A$, the construction somehow has to keep track of them. 
% \label{lower_part:intuition}
% \begin{figure}
% \begin{center}
% \RunTypes
% \caption{Different notions of runs.}
% \label{run_types}
% \end{center}
% \end{figure}

% The construction of the lower part takes as input the upper part $B^\prime$ (and the initial automaton $A$) and outputs the final complement automaton $B$ with $L(B) = \cl1{L(A)}$. The construction of the lower part is basically an extension of the construction of the upper part that is applied to the states of the upper part. The extension consists therein that every set in the states of the lower part is assigned a \emph{colour}. These colours will be used to keep track of certain properties of runs of $B$ that finally allow to decide which states of the lower part of $B$ may be accepting. In this section we will first explain the mechanical construction of $B$ and give the intuition behind it afterwards.

% There are three colours that sets of the lower part can have, let us call them 0, 1, and 2. The colour of a set says something about the history of the runs that reach this set. We have to clarify what we mean by run at this point. Conceptually, the subset-tuple construction unifies runs of the input automaton $A$. The construction conceptually includes two abstraction levels of this unification. Figure~\ref{runs} illustrates this. The figure shows three copies of two states of the upper part of the last section. The leftmost pair shows in dotted lines the runs of the original automaton $A$. These runs go from $A$-state to $A$-state, and are the ones that are unified by the construction. The middle part shows the conceptual unification of the $A$-runs to at most two outgoing branches per subset-tuple state, one for the accepting successors and one for the non-accepting successors. These runs go from state set to state set and correspond to the run analysis done with reduced split trees. The rightmost part finally shows the real run of the automaton excerpt. This is the run that is seen from the outside, when the inner structure of the states is now known. It unifies all the $A$-runs to one single run.

% In the following we will always refer to the notion of run in the middle of Figure~\ref{runs}. That is, the notion that directly corresponds to reduced split trees. This conceptual view unifies and simplifies the $A$-runs as much as possible, but still guards enough information for figuring out a correct acceptance behaviour of the final complement automaton $B$.

% A run arriving at a set is thus a branch of a corresponding reduced split tree. It can be obtained by starting at the node corresponding to the set in question and following the edges upwards toward the root of the tree. A given set may occur in many reduced split trees, as there is a reduced split tree for every word of $A$'s alphabet. The set of runs arriving at a set are thus the corresponding branches of all the reduced split tree where the set occurs.

% In the construction of the lower part, we are interested in the history of the runs back until the time when they left the upper part. The crucial information is whether this history of a run includes a so-called right-turn. The notion of right-turn can be understood figuratively. In a reduced split tree, a run can be thought of as having at any node $p$ the choice of either going to the accepting child of $p$ or to the non-accepting one. Since in the right-to-left version of reduced split trees accepting children are to the right of non-accepting children, the run literally ``turns right'' when going to the accepting child. Consequently, if a run has a right-turn in its history, then it has visited at least one accepting set since leaving the upper part. On the other hand, if a run has no right-turns in its history, then it has visited no accepting sets since leaving the upper part.

% That leads us back to the colours that we use for labelling the sets of the lower part. The meaning of the colours 0, 1, and 2 is the following.
% \begin{itemize}
% \item 2: the run includes a right-turn in the lower part
% \item 1: the run includes a right-turn in the lower part, but in the $B$-state where the run visited the accepting child, there was already another set with colour 2
% \item 0: the run does not include right-turns in the lower part
% \end{itemize}

% The role of colour 0 and colour 2 should be clear from the above explanations. The role colour 1 is more subtle and we will explain it later in this section when we give the intuition behind the selection of the accepting states of $B$. For now, we will complete the description of how to construct the lower part and thereby the final complement automaton $B$.

% As mentioned, constructing the states of the lower part is done in the same way as constructing the states of the upper part, with the difference that every set $s$ is assigned a colour. This colour depends on the colour of the predecessor set $s_{pred}$ of $s$ and on whether $s$ itself is an accepting or non-accepting set. Furthermore, there are different rules for the two cases where the $B$-state $p$ containing $s_{pred}$ contains one or more 2-coloured sets or does not contain any 2-coloured sets. Figure~\ref{colours} contains the complete rules for determining the colour of set $s$. Note that states of the upper part are treated as all their sets would have colour 0.


% The colour rules are in fact simple. The first rows in the two matrices in Figure~\ref{colours} treat the case where the run was still ``clean'' when it arrived at $s$'s predecessor $s_{pred}$. If now $s$ is the non-accepting child of $s_{pred}$, then the run stays clean and $s$ gets colour 0. But if $s$ is the accepting child, then the run just commits its first right-turn and gets dirty. Depending on whether there is another 2-coloured set in the state, $s$ gets either colour 1 or colour 2. The remaining rows in the matrices of Figure~\ref{colours} express the continuation of ``dirtiness''.

